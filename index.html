<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Bioinformatics Tool</title>
    <style>
      /* --- General Styling & Layout --- */
      :root {
        --primary-color: #667eea;
        --secondary-color: #764ba2;
        --danger-color: #ff6b6b;
        --success-color: #51cf66;
        --info-color: #17a2b8;
        --light-gray: #f8f9fa;
        --dark-text: #333;
        --light-text: #fff;
        --border-color: #ddd;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        min-height: 100vh;
        padding: 20px;
        color: var(--dark-text);
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: var(--light-text);
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      /* --- Typography --- */
      h1 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 10px;
        font-size: 2.5em;
      }
      h3 {
        color: var(--secondary-color);
        margin-bottom: 15px;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 5px;
      }
      h4 {
        color: #555;
        margin-bottom: 15px;
        font-size: 1.1em;
      }
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
      }

      /* --- Forms & Inputs --- */
      .method-selector,
      .upgma-input-selector {
        margin-bottom: 40px;
      }
      label {
        font-weight: 600;
        display: block;
        margin-bottom: 8px;
      }
      .label-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .label-with-tooltip {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .label-container label {
        margin-bottom: 0;
      }
      .align-select {
        width: auto;
        padding: 5px 8px;
        font-size: 14px;
        margin-left: 10px;
      }

      select,
      input[type="text"],
      input[type="number"],
      textarea {
        width: 100%;
        padding: 12px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s, box-shadow 0.3s;
      }

      /* --- Sequence Input Styling --- */
      textarea,
      .upgma-seq {
        text-transform: uppercase;
        font-family: "Courier New", monospace;
      }

      .input-warning {
        color: var(--danger-color);
        font-size: 13px;
        height: 1.2em;
        margin-top: 4px;
        opacity: 0;
        transition: opacity 0.3s ease-in-out;
        text-align: right;
      }
      .upgma-warning {
        grid-column: 4;
        text-align: left;
      }

      select:focus,
      input:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 5px rgba(102, 126, 234, 0.5);
      }

      textarea {
        min-height: 100px;
        resize: vertical;
      }
      .seq-counter {
        font-size: 14px;
        color: #666;
        text-align: right;
        margin-top: 4px;
        height: 1em;
      }

      .input-section {
        margin-bottom: 30px;
      }
      .params {
        margin-bottom: 20px;
      }
      .input-section,
      .params {
        display: grid;
        gap: 20px;
      }
      .input-section {
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      }
      .params {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }

      /* --- Buttons --- */
      .button-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 20px;
      }

      button {
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        color: var(--light-text);
        border: none;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.15s, box-shadow 0.15s;
        width: 100%;
        position: relative;
        overflow: hidden;
      }
      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }
      button:active:not(:disabled) {
        transform: translateY(0) scale(0.95);
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      button:disabled {
        background: #aaa;
        cursor: not-allowed;
      }
      .ripple {
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple-animation 0.6s linear;
        background-color: rgba(255, 255, 255, 0.7);
      }
      @keyframes ripple-animation {
        to {
          transform: scale(4);
          opacity: 0;
        }
      }

      .remove-btn {
        background: var(--danger-color);
      }
      .add-seq-btn,
      .matrix-control-btn {
        background: var(--success-color);
      }
      .matrix-control-btn.remove {
        background: var(--danger-color);
      }
      .export-btn {
        background: #007bff;
        margin-top: 20px;
      }
      .generate-btn {
        background: var(--info-color);
      }
      .reset-btn {
        background: #6c757d;
      }

      /* --- Random Sequence Generator --- */
      .random-seq-generator {
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        padding: 0 20px;
        margin: 20px 0 30px 0;
      }
      .random-seq-generator h4 {
        cursor: pointer;
        padding: 20px 0;
        margin: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .toggle-arrow {
        transition: transform 0.3s ease-in-out;
      }
      .random-seq-generator.expanded .toggle-arrow {
        transform: rotate(180deg);
      }
      .generator-content {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease-in-out, padding 0.3s ease-in-out;
      }
      .random-seq-generator.expanded .generator-content {
        max-height: 500px;
        padding-bottom: 20px;
      }
      .random-seq-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
      }
      .random-control-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .random-control-group .generate-btn {
        margin-top: auto;
      } /* Pushes button to bottom */

      /* --- Sections & Results --- */
      .method-section,
      .upgma-input-container {
        display: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      .method-section.active,
      .upgma-input-container.active {
        display: block;
        opacity: 1;
      }
      .result-section {
        margin-top: 30px;
        padding: 20px;
        background: var(--light-gray);
        border-radius: 8px;
        display: none;
      }
      .result-section.visible {
        display: block;
      }
      .matrix-container,
      .distance-matrices-container,
      .matrix-input-container {
        overflow-x: auto;
        margin: 20px 0;
        padding: 10px;
        background: var(--light-text);
        border-radius: 8px;
      }

      table {
        border-collapse: collapse;
        margin: 0 auto;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      th,
      td {
        border: 1px solid var(--border-color);
        padding: 10px;
        text-align: center;
        min-width: 55px;
        height: 55px;
        transition: background-color 0.2s;
        position: relative;
      }
      th {
        background: var(--primary-color);
        color: var(--light-text);
        font-weight: 600;
      }
      td {
        cursor: help;
      }
      td:hover {
        background-color: #f1f3f5;
      }
      .cell-path {
        background-color: #a29bfe !important;
        color: var(--light-text);
        font-weight: bold;
      }
      .cell-source {
        background-color: #fffbdd !important; /* A light yellow */
        color: #111 !important; /* Force text to be dark for readability */
      }
      .cell-source .trace-arrow {
        color: #111 !important; /* Ensure arrows are also dark */
      }

      /* --- Organized Arrow Styles --- */
      .trace-arrow {
        position: absolute;
        font-size: 1.2em;
        color: #333;
        font-weight: bold;
        line-height: 1;
        pointer-events: none;
      }
      .arrow-diag {
        top: 3px;
        left: 3px;
      }
      .arrow-up {
        top: 3px;
        left: 50%;
        transform: translateX(-50%);
      }
      .arrow-left {
        top: 50%;
        left: 3px;
        transform: translateY(-50%);
      }
      .cell-path .trace-arrow {
        color: var(--light-text);
      }

      /* --- ALIGNMENT RESULT STYLE FIX --- */
      .alignment-result {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 0 1ch;
        font-family: "Courier New", monospace;
        background: var(--light-text);
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        overflow-x: auto;
        font-size: 1.1em;
        line-height: 1.6;
      }
      .alignment-result .seq-label {
        text-align: right;
        font-weight: normal;
        white-space: nowrap;
      }
      .alignment-result .seq-data,
      .alignment-result .match-line {
        white-space: pre;
      }
      .alignment-result .match-line {
        color: #aaa;
      }
      .alignment-result span {
        font-weight: bold;
      }
      .match {
        color: var(--success-color);
      }
      .mismatch {
        color: var(--danger-color);
      }
      .score-display {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--primary-color);
        margin: 15px 0;
      }
      .result-note {
        font-size: 0.9em;
        color: #444;
        background-color: #e9ecef;
        padding: 10px;
        border-radius: 5px;
        margin-bottom: 20px;
      }

      /* --- Pill Style Toggle Buttons for Alignment --- */
      .alignment-switcher {
        margin: 20px 0;
        padding: 15px;
        background: #f1f3f5;
        border-radius: 8px;
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .alignment-switcher h4 {
        margin: 0 10px 0 0;
        padding: 0;
        color: #333;
        font-size: 1em;
        border: none;
      }
      .alignment-switcher input[type="radio"] {
        display: none;
      }
      .alignment-switcher label {
        font-weight: 600;
        cursor: pointer;
        padding: 8px 18px;
        border-radius: 20px;
        background-color: #fff;
        color: var(--dark-text);
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
      }
      .alignment-switcher input[type="radio"]:checked + label {
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        color: var(--light-text);
        box-shadow: 0 4px 10px rgba(102, 126, 234, 0.4);
        transform: translateY(-1px);
      }

      .alignment-result-item {
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid var(--border-color);
      }
      .alignment-result-item:first-of-type {
        margin-top: 10px;
      }
      #alignment-display > .alignment-result-item {
        border-top: none;
        padding-top: 0;
        margin-top: 0;
      }

      /* --- UPGMA Specific --- */
      .seq-item {
        display: grid;
        grid-template-columns: auto 1fr auto 1fr auto;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
        grid-template-rows: auto auto;
      }
      .seq-item label {
        margin: 0;
      }
      .upgma-options {
        margin: 25px 0;
        padding: 20px;
        border: 2px dashed var(--border-color);
        border-radius: 8px;
      }
      .remove-btn {
        width: auto;
        margin: 0;
      }
      .tree-container {
        margin-top: 20px;
        padding: 20px;
        background: var(--light-gray);
        border-radius: 8px;
        text-align: center;
        overflow-x: auto;
      }
      .tree-svg {
        border: 2px solid var(--border-color);
        border-radius: 8px;
        width: 100%;
        height: auto;
      }
      .step-log {
        text-align: left;
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        font-family: "Courier New", monospace;
      }

      /* --- Matrix Input Specific --- */
      .matrix-controls {
        display: flex;
        gap: 15px;
        margin-bottom: 20px;
      }
      .matrix-input-table input {
        width: 100%;
        min-width: 60px;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        text-align: center;
      }
      .matrix-input-table input:disabled {
        background-color: #eee;
        cursor: not-allowed;
      }
      .matrix-input-table th input {
        background: none;
        color: white;
        font-weight: bold;
        border: none;
      }

      /* --- Help & Calculation Tooltips --- */
      .help-tooltip {
        display: inline-block;
        width: 18px;
        height: 18px;
        line-height: 18px;
        text-align: center;
        border-radius: 50%;
        background: var(--info-color);
        color: white;
        font-size: 12px;
        font-weight: bold;
        cursor: help;
        position: relative;
        user-select: none;
      }
      .help-tooltip .tooltip-text {
        visibility: hidden;
        width: 300px;
        background-color: #2c3e50;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 10px;
        position: absolute;
        z-index: 100;
        bottom: 150%;
        left: 50%;
        margin-left: -150px;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 14px;
        font-weight: normal;
        line-height: 1.4;
      }
      .help-tooltip:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
      }

      .calc-tooltip {
        display: block; /* Use opacity and pointer-events for visibility */
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
        position: absolute;
        background-color: #2c3e50;
        color: white;
        padding: 15px;
        border: 1px solid #fff;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        z-index: 1000;
        font-size: 0.9em;
        width: auto;
        max-width: 500px;
        pointer-events: none; /* Avoid tooltip catching mouse events */
      }
      .calc-tooltip.visible {
        visibility: visible;
        opacity: 1;
      }

      .calc-tooltip table {
        width: 100%;
        border-collapse: collapse;
        box-shadow: none;
      }
      .calc-tooltip th,
      .calc-tooltip td {
        border: 1px solid #465d77;
        padding: 8px;
        text-align: left;
        min-width: auto;
        height: auto;
        color: white;
      }
      .calc-tooltip th {
        background: none;
        font-weight: bold;
        width: 40%;
      }
      .calc-tooltip .winning-score {
        font-weight: bold;
        color: #51cf66; /* success color */
      }
      .calc-tooltip .detail-text,
      .calc-tooltip .upgma-calc-detail {
        font-style: italic;
        font-size: 0.9em;
        color: #bdc3c7;
      }
      .calc-tooltip h4 {
        color: var(--light-text);
        margin-bottom: 10px;
        border-bottom: 1px solid #465d77;
        padding-bottom: 5px;
      }

      /* --- Signature --- */
      .signature {
        position: fixed;
        bottom: 10px;
        right: 15px;
        font-size: 12px;
        color: #fff;
        opacity: 0.7;
        font-family: "Courier New", monospace;
        z-index: 1001;
      }

      /* --- Responsive Design --- */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 2em;
        }
        .subtitle {
          font-size: 1em;
        }

        .input-section,
        .params,
        .random-seq-controls,
        .button-group {
          grid-template-columns: 1fr;
        }

        /* Responsive UPGMA Sequence Items */
        .seq-item {
          grid-template-columns: 1fr; /* Stack all items into a single column */
          gap: 10px;
          margin-bottom: 30px; /* Add more space between items */
          padding-bottom: 20px; /* Add padding for the border */
          border-bottom: 1px solid var(--border-color);
        }
        .seq-item label {
          margin-bottom: 0;
          text-align: left; /* Align labels to the left */
        }
        .seq-item input {
          width: 100%; /* Ensure inputs take full width */
        }
        .remove-btn {
          width: 100%;
          margin-top: 10px;
        }
        .upgma-warning {
          grid-column: 1; /* Ensure warning is in the single column */
          text-align: left;
        }

        /* Responsive Matrix Controls */
        .matrix-controls {
          flex-direction: column;
        }
        .matrix-controls .matrix-control-btn {
          width: 100%;
        }

        /* Alignment Switcher (Pills) */
        .alignment-switcher {
          flex-direction: column;
          align-items: flex-start;
        }
        .alignment-switcher h4 {
          margin-bottom: 15px;
        }

        /* General Button and Input Adjustments */
        button {
          padding: 12px 20px;
        }
        select,
        input[type="text"],
        input[type="number"],
        textarea {
          padding: 10px;
          font-size: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>🧬 Advanced Bioinformatics Tool</h1>
      <p class="subtitle">
        Global Alignment • Local Alignment • UPGMA Tree Building
      </p>
      <div class="method-selector">
        <label for="method">Select Method:</label>
        <select id="method">
          <option value="global">Global Alignment (Needleman-Wunsch)</option>
          <option value="local">Local Alignment (Smith-Waterman)</option>
          <option value="upgma">UPGMA Tree Building</option>
        </select>
      </div>

      <!-- Alignment Section (Global/Local) -->
      <div id="alignment-section" class="method-section active">
        <div class="input-section">
          <div>
            <div class="label-container">
              <label for="seq1">Sequence 1:</label>
              <select id="seq1-align" class="align-select">
                <option value="row" selected>Align to Row</option>
                <option value="col">Align to Column</option>
              </select>
            </div>
            <textarea id="seq1" placeholder="e.g., GATTACA">GATTACA</textarea>
            <div class="input-warning"></div>
            <div id="seq1-counter" class="seq-counter"></div>
          </div>
          <div>
            <div class="label-container">
              <label for="seq2">Sequence 2:</label>
              <select id="seq2-align" class="align-select">
                <option value="row">Align to Row</option>
                <option value="col" selected>Align to Column</option>
              </select>
            </div>
            <textarea id="seq2" placeholder="e.g., GTCGACGCA">
GTCGACGCA</textarea
            >
            <div class="input-warning"></div>
            <div id="seq2-counter" class="seq-counter"></div>
          </div>
        </div>
        <div class="params">
          <div>
            <label for="match">Match Score:</label
            ><input type="number" id="match" value="1" />
          </div>
          <div>
            <label for="mismatch">Mismatch Score:</label
            ><input type="number" id="mismatch" value="-1" />
          </div>
          <div>
            <label for="gap">Gap Penalty:</label
            ><input type="number" id="gap" value="-1" />
          </div>
          <div>
            <div class="label-with-tooltip">
              <label for="traceback-priority">Traceback Priority:</label>
              <div class="help-tooltip">
                ?
                <span class="tooltip-text"
                  >Determines which path to follow when multiple alignment paths
                  have the same score. 'Diagonal' is prioritized for
                  matches/mismatches, 'Up' (Top) and 'Left' correspond to
                  gaps.</span
                >
              </div>
            </div>
            <select id="traceback-priority">
              <option value="diag-up-left" selected>
                Diagonal → Up → Left
              </option>
              <option value="diag-left-up">Diagonal → Left → Up</option>
              <option value="up-diag-left">Up → Diagonal → Left</option>
              <option value="up-left-diag">Up → Left → Diagonal</option>
              <option value="left-diag-up">Left → Diagonal → Up</option>
              <option value="left-up-diag">Left → Up → Diagonal</option>
            </select>
          </div>
        </div>

        <!-- Random Sequence Generator -->
        <div class="random-seq-generator">
          <h4>Random Sequence Generator <span class="toggle-arrow">▼</span></h4>
          <div class="generator-content">
            <div class="random-seq-controls">
              <div class="random-control-group">
                <label for="random-len1">Sequence 1 Length:</label>
                <input type="number" id="random-len1" value="15" min="1" />
                <button id="generate-seq1-btn" class="generate-btn">
                  Generate for Sequence 1
                </button>
              </div>
              <div class="random-control-group">
                <label for="random-len2">Sequence 2 Length:</label>
                <input type="number" id="random-len2" value="15" min="1" />
                <button id="generate-seq2-btn" class="generate-btn">
                  Generate for Sequence 2
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="button-group">
          <button id="compute-alignment-btn">Compute Alignment</button>
          <button id="reset-btn" class="reset-btn">Reset (R)</button>
        </div>

        <div id="alignment-results" class="result-section">
          <h3>Alignment Matrix</h3>
          <p>Hover over a cell to see source cells; click for details.</p>
          <div class="matrix-container" id="matrix-display"></div>
          <h3>Optimal Alignment(s)</h3>
          <div id="result-notes-container"></div>
          <div class="score-display" id="score-display"></div>
          <div id="alignment-display"></div>
        </div>
      </div>

      <!-- UPGMA Section -->
      <div id="upgma-section" class="method-section">
        <div class="upgma-input-selector">
          <label for="upgma-input-method">Input Method:</label>
          <select id="upgma-input-method">
            <option value="sequence">Sequence Input</option>
            <option value="matrix">Initial Distance Matrix</option>
          </select>
        </div>

        <!-- UPGMA Sequence Input Container -->
        <div id="upgma-sequence-container" class="upgma-input-container active">
          <div id="seq-container">
            <!-- Initial sequences will be added here by JS -->
          </div>
          <div class="upgma-options">
            <div class="label-with-tooltip">
              <label for="upgma-distance-method"
                >Distance Calculation Method:</label
              >
              <div class="help-tooltip">
                ?
                <span class="tooltip-text"
                  ><b>Absolute Difference:</b> Counts the total number of
                  differing positions.<br /><br /><b>Equation Method:</b>
                  Calculates the proportion of differences (number of
                  differences / total aligned positions). (normalized 0-1
                  distance for 'equation' method).</span
                >
              </div>
            </div>
            <select id="upgma-distance-method">
              <option value="traditional">Absolute Difference</option>
              <option value="equation" selected>
                Use Equation (Number of Differences / Total Positions)
              </option>
            </select>
          </div>
          <button class="add-seq-btn" id="add-seq-btn">Add Sequence</button>
        </div>

        <!-- UPGMA Matrix Input Container -->
        <div id="upgma-matrix-container" class="upgma-input-container">
          <h4>Enter Initial Distances</h4>
          <div class="matrix-controls">
            <button id="add-matrix-row-btn" class="matrix-control-btn">
              Add Row/Column
            </button>
            <button
              id="remove-matrix-row-btn"
              class="matrix-control-btn remove"
            >
              Remove Row/Column
            </button>
          </div>
          <div class="matrix-input-container" id="matrix-input-display"></div>
        </div>

        <div class="button-group">
          <button id="build-upgma-btn">Build UPGMA Tree</button>
          <button id="reset-upgma-btn" class="reset-btn">Reset (R)</button>
        </div>
        <div id="upgma-results" class="result-section">
          <h3>UPGMA Clustering Process</h3>
          <div id="upgma-info-container"></div>
          <div class="step-log" id="upgma-step-log"></div>
          <div class="distance-matrices-container" id="distance-matrices"></div>
          <h3>Phylogenetic Tree</h3>
          <div class="tree-container" id="tree-display"></div>
          <button class="export-btn" id="export-svg-btn">
            Export Tree as SVG
          </button>
        </div>
      </div>
      <!-- Calculation Tooltip -->
      <div id="calc-tooltip" class="calc-tooltip"></div>
    </div>
    <div class="signature">Made by Rahim</div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const app = {
          elements: {
            methodSelect: document.getElementById("method"),
            alignmentSection: document.getElementById("alignment-section"),
            upgmaSection: document.getElementById("upgma-section"),
            computeAlignmentBtn: document.getElementById(
              "compute-alignment-btn"
            ),
            buildUpgmaBtn: document.getElementById("build-upgma-btn"),
            addSeqBtn: document.getElementById("add-seq-btn"),
            exportSvgBtn: document.getElementById("export-svg-btn"),
            seq1Input: document.getElementById("seq1"),
            seq2Input: document.getElementById("seq2"),
            seq1Counter: document.getElementById("seq1-counter"),
            seq2Counter: document.getElementById("seq2-counter"),
            seq1Align: document.getElementById("seq1-align"),
            seq2Align: document.getElementById("seq2-align"),
            matchInput: document.getElementById("match"),
            mismatchInput: document.getElementById("mismatch"),
            gapInput: document.getElementById("gap"),
            tracebackPriority: document.getElementById("traceback-priority"),
            alignmentResults: document.getElementById("alignment-results"),
            matrixDisplay: document.getElementById("matrix-display"),
            scoreDisplay: document.getElementById("score-display"),
            alignmentDisplay: document.getElementById("alignment-display"),
            resultNotesContainer: document.getElementById(
              "result-notes-container"
            ),
            randomLen1Input: document.getElementById("random-len1"),
            generateSeq1Btn: document.getElementById("generate-seq1-btn"),
            randomLen2Input: document.getElementById("random-len2"),
            generateSeq2Btn: document.getElementById("generate-seq2-btn"),
            generatorContainer: document.querySelector(".random-seq-generator"),
            generatorHeader: document.querySelector(".random-seq-generator h4"),
            // UPGMA Elements
            upgmaInputMethod: document.getElementById("upgma-input-method"),
            upgmaSequenceContainer: document.getElementById(
              "upgma-sequence-container"
            ),
            upgmaMatrixContainer: document.getElementById(
              "upgma-matrix-container"
            ),
            seqContainer: document.getElementById("seq-container"),
            upgmaDistanceMethod: document.getElementById(
              "upgma-distance-method"
            ),
            upgmaResults: document.getElementById("upgma-results"),
            upgmaInfoContainer: document.getElementById("upgma-info-container"),
            stepLog: document.getElementById("upgma-step-log"),
            distanceMatrices: document.getElementById("distance-matrices"),
            treeDisplay: document.getElementById("tree-display"),
            addMatrixRowBtn: document.getElementById("add-matrix-row-btn"),
            removeMatrixRowBtn: document.getElementById(
              "remove-matrix-row-btn"
            ),
            matrixInputDisplay: document.getElementById("matrix-input-display"),
            calcTooltip: document.getElementById("calc-tooltip"),
            resetBtns: document.querySelectorAll(".reset-btn"),
          },
          state: {
            upgmaSeqCount: 0,
            lastAlignmentResult: null,
            lastUPGMAResult: null,
            matrixInputSize: 3,
          },

          init() {
            this.addInitialUpgmaSequences();
            this.renderMatrixInput();
            this.bindEvents();
            this.updateSeqCounters();
            this.handleMethodSwitch(); // Set initial UI state
            this.handleUpgmaInputSwitch(); // Set initial UPGMA UI state
          },

          bindEvents() {
            this.elements.methodSelect.addEventListener(
              "change",
              this.handleMethodSwitch.bind(this)
            );
            this.elements.computeAlignmentBtn.addEventListener(
              "click",
              this.handleAlignment.bind(this)
            );
            this.elements.buildUpgmaBtn.addEventListener(
              "click",
              this.handleUPGMA.bind(this)
            );
            this.elements.addSeqBtn.addEventListener("click", () =>
              this.addUpgmaSequence()
            );
            this.elements.exportSvgBtn.addEventListener(
              "click",
              this.exportSVG.bind(this)
            );
            this.elements.seq1Align.addEventListener(
              "change",
              this.handleAlignSwitch.bind(this)
            );
            this.elements.seq2Align.addEventListener(
              "change",
              this.handleAlignSwitch.bind(this)
            );

            // UPGMA Input Switcher
            this.elements.upgmaInputMethod.addEventListener(
              "change",
              this.handleUpgmaInputSwitch.bind(this)
            );
            this.elements.addMatrixRowBtn.addEventListener("click", () => {
              this.state.matrixInputSize++;
              this.renderMatrixInput();
            });
            this.elements.removeMatrixRowBtn.addEventListener("click", () => {
              if (this.state.matrixInputSize > 2) {
                this.state.matrixInputSize--;
                this.renderMatrixInput();
              }
            });

            // Input validation and counters
            const seqInputs = [
              this.elements.seq1Input,
              this.elements.seq2Input,
            ];
            seqInputs.forEach((input) => {
              input.addEventListener("input", this.sanitizeAndWarn.bind(this));
              input.addEventListener(
                "input",
                this.updateSeqCounters.bind(this)
              );
            });

            // Hide tooltip on outside click
            document.addEventListener("click", (e) => {
              if (!e.target.closest("td")) {
                this.elements.calcTooltip.classList.remove("visible");
              }
            });

            // Random sequence generator
            this.elements.generateSeq1Btn.addEventListener("click", () => {
              const len = parseInt(this.elements.randomLen1Input.value) || 15;
              this.elements.seq1Input.value = this.generateRandomSequence(len);
              this.updateSeqCounters();
            });
            this.elements.generateSeq2Btn.addEventListener("click", () => {
              const len = parseInt(this.elements.randomLen2Input.value) || 15;
              this.elements.seq2Input.value = this.generateRandomSequence(len);
              this.updateSeqCounters();
            });
            this.elements.generatorHeader.addEventListener("click", () => {
              this.elements.generatorContainer.classList.toggle("expanded");
            });

            // Reset functionality
            this.elements.resetBtns.forEach((btn) =>
              btn.addEventListener("click", this.reset.bind(this))
            );
            document.addEventListener("keydown", (e) => {
              if (e.key.toLowerCase() === "r") {
                e.preventDefault();
                this.reset();
              }
            });

            // Button ripple effect
            const buttons = document.querySelectorAll("button");
            buttons.forEach((button) => {
              button.addEventListener("click", this.createRipple);
            });
          },

          reset() {
            this.elements.alignmentResults.classList.remove("visible");
            this.elements.upgmaResults.classList.remove("visible");
            this.elements.matrixDisplay.innerHTML = "";
            this.elements.alignmentDisplay.innerHTML = "";
            this.elements.scoreDisplay.innerHTML = "";
            this.elements.resultNotesContainer.innerHTML = "";
            this.elements.upgmaInfoContainer.innerHTML = "";
            this.elements.stepLog.innerHTML = "";
            this.elements.distanceMatrices.innerHTML = "";
            this.elements.treeDisplay.innerHTML = "";
          },

          createRipple(event) {
            const button = event.currentTarget;
            const circle = document.createElement("span");
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;

            circle.style.width = circle.style.height = `${diameter}px`;
            const buttonRect = button.getBoundingClientRect();
            circle.style.left = `${event.clientX - buttonRect.left - radius}px`;
            circle.style.top = `${event.clientY - buttonRect.top - radius}px`;
            circle.classList.add("ripple");

            const ripple = button.getElementsByClassName("ripple")[0];
            if (ripple) {
              ripple.remove();
            }

            button.appendChild(circle);
          },

          sanitizeAndWarn(event) {
            const input = event.target;
            const originalValue = input.value;
            const cursorPosition = input.selectionStart;

            // Sanitize: convert to uppercase and remove invalid characters
            const sanitizedValue = originalValue
              .toUpperCase()
              .replace(/[^ATCGU]/g, "");

            if (originalValue !== sanitizedValue) {
              const diff = originalValue.length - sanitizedValue.length;
              input.value = sanitizedValue;
              // Try to adjust cursor position logically
              const newCursorPos = Math.max(0, cursorPosition - diff);
              input.setSelectionRange(newCursorPos, newCursorPos);

              // Show warning message
              this.showInputWarning(input, "Only A, T, C, G, U are allowed.");
            }
          },

          showInputWarning(inputElement, message) {
            let warningEl =
              inputElement.parentElement.querySelector(".input-warning");
            if (!warningEl) return;

            warningEl.textContent = message;
            warningEl.style.opacity = "1";

            if (warningEl.timer) {
              clearTimeout(warningEl.timer);
            }

            warningEl.timer = setTimeout(() => {
              warningEl.style.opacity = "0";
            }, 2500);
          },

          updateSeqCounters() {
            const len1 = this.elements.seq1Input.value.replace(
              /\s/g,
              ""
            ).length;
            this.elements.seq1Counter.textContent = `Length: ${len1}`;
            const len2 = this.elements.seq2Input.value.replace(
              /\s/g,
              ""
            ).length;
            this.elements.seq2Counter.textContent = `Length: ${len2}`;
          },

          handleAlignSwitch(event) {
            const changedSelect = event.target;
            const otherSelect =
              changedSelect === this.elements.seq1Align
                ? this.elements.seq2Align
                : this.elements.seq1Align;

            if (changedSelect.value === "row") {
              otherSelect.value = "col";
            } else {
              otherSelect.value = "row";
            }
          },

          handleMethodSwitch() {
            const method = this.elements.methodSelect.value;
            this.elements.alignmentSection.classList.toggle(
              "active",
              method === "global" || method === "local"
            );
            this.elements.upgmaSection.classList.toggle(
              "active",
              method === "upgma"
            );
          },

          handleUpgmaInputSwitch() {
            const inputMethod = this.elements.upgmaInputMethod.value;
            this.elements.upgmaSequenceContainer.classList.toggle(
              "active",
              inputMethod === "sequence"
            );
            this.elements.upgmaMatrixContainer.classList.toggle(
              "active",
              inputMethod === "matrix"
            );
          },

          handleAlignment() {
            const btn = this.elements.computeAlignmentBtn;
            this.toggleButtonLoading(btn, true);
            this.reset();
            setTimeout(() => {
              try {
                const method = this.elements.methodSelect.value;
                const seq1 = this.elements.seq1Input.value
                  .toUpperCase()
                  .replace(/\s/g, "");
                const seq2 = this.elements.seq2Input.value
                  .toUpperCase()
                  .replace(/\s/g, "");

                const seq1IsRow = this.elements.seq1Align.value === "row";
                const seq_v = seq1IsRow ? seq1 : seq2;
                const seq_h = seq1IsRow ? seq2 : seq1;

                if (!seq_v || !seq_h) {
                  alert("Please enter both sequences.");
                  return;
                }

                const match = parseInt(this.elements.matchInput.value);
                const mismatch = parseInt(this.elements.mismatchInput.value);
                const gap = parseInt(this.elements.gapInput.value);

                const result =
                  method === "global"
                    ? this.needlemanWunsch(seq_v, seq_h, match, mismatch, gap)
                    : this.smithWaterman(seq_v, seq_h, match, mismatch, gap);

                result.seq_v = seq_v;
                result.seq_h = seq_h;
                result.seq1IsRow = seq1IsRow;
                result.params = { match, mismatch, gap };

                this.state.lastAlignmentResult = result;
                this.displayAlignmentResults(result);
              } catch (e) {
                console.error("Alignment Error:", e);
                alert("An error occurred during alignment.");
              } finally {
                this.toggleButtonLoading(btn, false);
              }
            }, 50);
          },

          handleUPGMA() {
            const btn = this.elements.buildUpgmaBtn;
            this.toggleButtonLoading(btn, true);
            this.reset();
            setTimeout(() => {
              try {
                const inputMethod = this.elements.upgmaInputMethod.value;
                let result;

                if (inputMethod === "sequence") {
                  const sequences = Array.from(
                    this.elements.seqContainer.querySelectorAll(".upgma-seq")
                  ).map((el) => el.value.toUpperCase().replace(/\s/g, ""));
                  const names = Array.from(
                    this.elements.seqContainer.querySelectorAll(".upgma-name")
                  ).map((el) => el.value.trim());
                  if (sequences.filter((s) => s).length < 2) {
                    throw new Error(
                      "Please provide at least two sequences for UPGMA."
                    );
                  }
                  const distanceMethod =
                    this.elements.upgmaDistanceMethod.value;
                  result = this.upgmaFromSequences(
                    sequences,
                    names,
                    distanceMethod
                  );
                  result.distanceMethod = distanceMethod;
                } else {
                  // Matrix Input
                  const { matrix, labels } = this.readMatrixFromDOM();
                  if (labels.length < 2) {
                    throw new Error(
                      "Please provide at least two rows/columns in the distance matrix."
                    );
                  }
                  result = this.upgmaFromMatrix(matrix, labels);
                }

                this.state.lastUPGMAResult = result;
                this.displayUPGMAResults(result);
              } catch (e) {
                console.error("UPGMA Error:", e);
                alert("Error during UPGMA tree construction: " + e.message);
              } finally {
                this.toggleButtonLoading(btn, false);
              }
            }, 50);
          },

          needlemanWunsch(seq_v, seq_h, match, mismatch, gap) {
            const m = seq_v.length,
              n = seq_h.length;
            const matrix = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(0));
            const traceback = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(null));
            for (let i = 1; i <= m; i++) {
              matrix[i][0] = i * gap;
              traceback[i][0] = ["up"];
            }
            for (let j = 1; j <= n; j++) {
              matrix[0][j] = j * gap;
              traceback[0][j] = ["left"];
            }
            for (let i = 1; i <= m; i++) {
              for (let j = 1; j <= n; j++) {
                const matchScore =
                  seq_v[i - 1] === seq_h[j - 1] ? match : mismatch;
                const diag = matrix[i - 1][j - 1] + matchScore;
                const up = matrix[i - 1][j] + gap;
                const left = matrix[i][j - 1] + gap;

                const maxScore = Math.max(diag, up, left);
                matrix[i][j] = maxScore;

                traceback[i][j] = [];
                if (maxScore === diag) traceback[i][j].push("diag");
                if (maxScore === up) traceback[i][j].push("up");
                if (maxScore === left) traceback[i][j].push("left");
              }
            }

            const alignments = this.getAllAlignments(
              matrix,
              traceback,
              seq_v,
              seq_h,
              m,
              n,
              false
            );

            return {
              matrix,
              traceback,
              score: matrix[m][n],
              alignments: alignments,
              type: "Global",
            };
          },

          smithWaterman(seq_v, seq_h, match, mismatch, gap) {
            const m = seq_v.length,
              n = seq_h.length;
            const matrix = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(0));
            const traceback = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(null));
            let maxScore = 0;
            let maxCoords = [];

            for (let i = 1; i <= m; i++) {
              for (let j = 1; j <= n; j++) {
                const matchScore =
                  seq_v[i - 1] === seq_h[j - 1] ? match : mismatch;
                const diag = matrix[i - 1][j - 1] + matchScore;
                const up = matrix[i - 1][j] + gap;
                const left = matrix[i][j - 1] + gap;

                const currentMax = Math.max(0, diag, up, left);
                matrix[i][j] = currentMax;

                traceback[i][j] = [];
                if (currentMax > 0) {
                  if (currentMax === diag) traceback[i][j].push("diag");
                  if (currentMax === up) traceback[i][j].push("up");
                  if (currentMax === left) traceback[i][j].push("left");
                } else {
                  traceback[i][j].push("stop");
                }

                if (matrix[i][j] > maxScore) {
                  maxScore = matrix[i][j];
                  maxCoords = [[i, j]];
                } else if (matrix[i][j] === maxScore && maxScore > 0) {
                  maxCoords.push([i, j]);
                }
              }
            }

            const priority =
              this.elements.tracebackPriority.value || "diag-up-left";
            const alignments = [];
            if (maxCoords.length === 0 && maxScore === 0) {
              alignments.push({
                aligned_v: "",
                aligned_h: "",
                path: new Set(),
                start_i: 0,
                start_j: 0,
              });
            } else {
              for (const [maxI, maxJ] of maxCoords) {
                const alignment = this.getAlignment(
                  matrix,
                  traceback,
                  seq_v,
                  seq_h,
                  maxI,
                  maxJ,
                  true,
                  priority
                );
                alignments.push(alignment);
              }
            }

            return {
              matrix,
              traceback,
              score: maxScore,
              alignments,
              type: "Local",
            };
          },

          getAlignment(
            matrix,
            traceback,
            seq_v,
            seq_h,
            i,
            j,
            isLocal = false,
            priority = "diag-up-left"
          ) {
            let aligned_v = "",
              aligned_h = "";
            const path = new Set();
            let current_i = i,
              current_j = j;
            while (current_i > 0 || current_j > 0) {
              path.add(`${current_i},${current_j}`);
              const directions = traceback[current_i][current_j];
              if (!directions || directions.length === 0) break;

              let direction;
              const priorityOrder = priority.split("-");
              for (const dir of priorityOrder) {
                if (directions.includes(dir)) {
                  direction = dir;
                  break;
                }
              }

              if (!direction) direction = directions[0];
              if (
                isLocal &&
                (direction === "stop" || matrix[current_i][current_j] === 0)
              )
                break;

              if (direction === "diag") {
                aligned_v = seq_v[current_i - 1] + aligned_v;
                aligned_h = seq_h[current_j - 1] + aligned_h;
                current_i--;
                current_j--;
              } else if (direction === "up") {
                aligned_v = seq_v[current_i - 1] + aligned_v;
                aligned_h = "-" + aligned_h;
                current_i--;
              } else if (direction === "left") {
                aligned_v = "-" + aligned_v;
                aligned_h = seq_h[current_j - 1] + aligned_h;
                current_j--;
              } else break;
            }
            return {
              aligned_v,
              aligned_h,
              path,
              start_i: current_i,
              start_j: current_j,
              end_i: i,
              end_j: j,
            };
          },

          getAllAlignments(matrix, traceback, seq_v, seq_h, m, n, isLocal) {
            const results = [];
            const stack = [
              { i: m, j: n, path: new Set(), aln_v: "", aln_h: "" },
            ];
            const visited = new Set();

            while (stack.length > 0) {
              const { i, j, path, aln_v, aln_h } = stack.pop();

              const stateKey = `${i}-${j}-${aln_v}-${aln_h}`;
              if (visited.has(stateKey)) continue;
              visited.add(stateKey);

              const newPath = new Set(path);
              newPath.add(`${i},${j}`);

              if (
                (!isLocal && i === 0 && j === 0) ||
                (isLocal && (matrix[i][j] === 0 || !traceback[i][j]))
              ) {
                results.push({
                  aligned_v: aln_v,
                  aligned_h: aln_h,
                  path: newPath,
                  start_i: i,
                  start_j: j,
                  end_i: m,
                  end_j: n,
                });
                continue;
              }

              const directions = traceback[i][j] || [];
              for (const dir of directions) {
                if (dir === "diag") {
                  stack.push({
                    i: i - 1,
                    j: j - 1,
                    path: newPath,
                    aln_v: seq_v[i - 1] + aln_v,
                    aln_h: seq_h[j - 1] + aln_h,
                  });
                }
                if (dir === "up") {
                  stack.push({
                    i: i - 1,
                    j: j,
                    path: newPath,
                    aln_v: seq_v[i - 1] + aln_v,
                    aln_h: "-" + aln_h,
                  });
                }
                if (dir === "left") {
                  stack.push({
                    i: i,
                    j: j - 1,
                    path: newPath,
                    aln_v: "-" + aln_v,
                    aln_h: seq_h[j - 1] + aln_h,
                  });
                }
              }
            }
            // Deduplicate final alignments
            const uniqueAlignments = {};
            for (const res of results) {
              uniqueAlignments[res.aligned_v + "|" + res.aligned_h] = res;
            }
            return Object.values(uniqueAlignments);
          },

          displayAlignmentResults(result) {
            const {
              matrix,
              traceback,
              score,
              alignments,
              seq_v,
              seq_h,
              seq1IsRow,
              type,
            } = result;

            let tableHTML =
              "<table><thead><tr><th></th><th>-</th>" +
              [...seq_h].map((c) => `<th>${c}</th>`).join("") +
              "</tr></thead><tbody>";
            for (let i = 0; i <= seq_v.length; i++) {
              tableHTML += `<tr><th>${i === 0 ? "-" : seq_v[i - 1]}</th>`;
              for (let j = 0; j <= seq_h.length; j++) {
                let arrowHTML = "";
                if (traceback[i] && traceback[i][j]) {
                  if (traceback[i][j].includes("diag"))
                    arrowHTML += `<span class="trace-arrow arrow-diag">↖</span>`;
                  if (traceback[i][j].includes("up"))
                    arrowHTML += `<span class="trace-arrow arrow-up">↑</span>`;
                  if (traceback[i][j].includes("left"))
                    arrowHTML += `<span class="trace-arrow arrow-left">←</span>`;
                }
                tableHTML += `<td data-i="${i}" data-j="${j}">${arrowHTML}${matrix[i][j]}</td>`;
              }
              tableHTML += "</tr>";
            }
            this.elements.matrixDisplay.innerHTML =
              tableHTML + "</tbody></table>";
            this.addMatrixEventListeners();

            let note = "";
            if (type === "Local" && alignments.length > 1) {
              note =
                '<div class="result-note">Multiple alignments may appear if several local maxima exist.</div>';
            } else if (alignments.length > 1) {
              note =
                '<div class="result-note">Multiple optimal alignments exist and are shown below.</div>';
            }
            this.elements.resultNotesContainer.innerHTML = note;

            if (type === "Local") {
              this.elements.scoreDisplay.textContent = `Found ${alignments.length} optimal local alignment(s) with a score of ${score}.`;
            } else {
              this.elements.scoreDisplay.textContent = `Found ${alignments.length} optimal global alignment(s) with a score of ${score}.`;
            }

            let multiAlignmentHTML = "";
            if (alignments.length > 1) {
              multiAlignmentHTML +=
                '<div class="alignment-switcher"><h4>View Alignment Path:</h4>';
              alignments.forEach((_, index) => {
                multiAlignmentHTML += `
                        <input type="radio" name="alignment-choice" id="aln-choice-${index}" value="${index}" ${
                  index === 0 ? "checked" : ""
                }>
                        <label for="aln-choice-${index}">Alignment ${
                  index + 1
                }</label>
                    `;
              });
              multiAlignmentHTML += "</div>";
            }

            alignments.forEach((aln, index) => {
              const final_aligned1 = seq1IsRow ? aln.aligned_v : aln.aligned_h;
              const final_aligned2 = seq1IsRow ? aln.aligned_h : aln.aligned_v;

              let colored_seq1 = "";
              let colored_seq2 = "";
              let matchLine = "";

              for (let i = 0; i < final_aligned1.length; i++) {
                const char1 = final_aligned1[i];
                const char2 = final_aligned2[i];
                let charClass = "";

                if (char1 === "-" || char2 === "-") {
                  matchLine += " ";
                } else if (char1 === char2) {
                  matchLine += "|";
                  charClass = "match";
                } else {
                  matchLine += ".";
                  charClass = "mismatch";
                }
                colored_seq1 += `<span class="${charClass}">${char1}</span>`;
                colored_seq2 += `<span class="${charClass}">${char2}</span>`;
              }

              multiAlignmentHTML += `<div class="alignment-result-item" id="alignment-detail-${index}">`;
              if (alignments.length > 1) {
                const startText =
                  type === "Local"
                    ? `(Ends at matrix cell [${aln.end_i}, ${aln.end_j}])`
                    : "";
                multiAlignmentHTML += `<h4>Alignment ${
                  index + 1
                } ${startText}</h4>`;
              }

              // --- HTML STRUCTURE FIX ---
              multiAlignmentHTML += `<div class="alignment-result">
                <span class="seq-label">Seq 1:</span><span class="seq-data">${colored_seq1}</span>
                <span class="seq-label"></span><span class="match-line">${matchLine}</span>
                <span class="seq-label">Seq 2:</span><span class="seq-data">${colored_seq2}</span>
              </div>`;

              multiAlignmentHTML += "</div>";
            });

            this.elements.alignmentDisplay.innerHTML = multiAlignmentHTML;

            const updatePathDisplay = (index) => {
              this.elements.matrixDisplay
                .querySelectorAll("td.cell-path")
                .forEach((c) => c.classList.remove("cell-path"));
              if (alignments[index]) {
                const path = alignments[index].path;
                path.forEach((coord) => {
                  const [i, j] = coord.split(",");
                  const cell = this.elements.matrixDisplay.querySelector(
                    `[data-i="${i}"][data-j="${j}"]`
                  );
                  if (cell) cell.classList.add("cell-path");
                });
              }
              // Hide/show alignment details
              document
                .querySelectorAll(".alignment-result-item")
                .forEach((item, idx) => {
                  item.style.display = idx == index ? "block" : "none";
                });
            };

            const radios = this.elements.alignmentDisplay.querySelectorAll(
              'input[name="alignment-choice"]'
            );
            if (radios.length > 0) {
              radios.forEach((radio) => {
                radio.addEventListener("change", (e) =>
                  updatePathDisplay(e.target.value)
                );
              });
            }

            updatePathDisplay(0);

            this.elements.alignmentResults.classList.add("visible");
          },

          addMatrixEventListeners() {
            this.elements.matrixDisplay
              .querySelectorAll("td")
              .forEach((cell) => {
                cell.addEventListener("mouseover", (e) => {
                  const i = parseInt(e.currentTarget.dataset.i);
                  const j = parseInt(e.currentTarget.dataset.j);
                  if (i === 0 && j === 0) return;
                  const { traceback } = this.state.lastAlignmentResult;
                  const directions = traceback[i] ? traceback[i][j] || [] : [];
                  directions.forEach((direction) => {
                    if (direction === "diag" || direction === "stop") {
                      if (i > 0 && j > 0) this.highlightCell(i - 1, j - 1);
                    }
                    if (direction === "up" || direction === "stop") {
                      if (i > 0) this.highlightCell(i - 1, j);
                    }
                    if (direction === "left" || direction === "stop") {
                      if (j > 0) this.highlightCell(i, j - 1);
                    }
                  });
                });
                cell.addEventListener("mouseout", () =>
                  this.elements.matrixDisplay
                    .querySelectorAll(".cell-source")
                    .forEach((c) => c.classList.remove("cell-source"))
                );

                cell.addEventListener("click", (e) => {
                  const i = parseInt(e.currentTarget.dataset.i);
                  const j = parseInt(e.currentTarget.dataset.j);
                  this.showCalculationTooltip(i, j, e);
                });
              });
          },

          showCalculationTooltip(i, j, event) {
            const { matrix, seq_v, seq_h, params, type } =
              this.state.lastAlignmentResult;
            if (i === 0 && j === 0) return;

            let tooltipContent = "<table>";

            if (i > 0 && j > 0) {
              const prevScore = matrix[i - 1][j - 1];
              const charV = seq_v[i - 1];
              const charH = seq_h[j - 1];
              const isMatch = charV === charH;
              const scoreAdd = isMatch ? params.match : params.mismatch;
              const total = prevScore + scoreAdd;
              const reason = isMatch ? "match" : "mismatch";
              tooltipContent += `
                    <tr>
                        <th>Score from Diagonal</th>
                        <td>${prevScore} + ${scoreAdd} = <b>${total}</b>
                            <div class="detail-text">(Due to a ${reason} between ${charV} & ${charH})</div>
                        </td>
                    </tr>`;
            }
            if (i > 0) {
              const prevScore = matrix[i - 1][j];
              const total = prevScore + params.gap;
              tooltipContent += `
                    <tr>
                        <th>Score from Upper</th>
                        <td>${prevScore} + (${params.gap}) = <b>${total}</b>
                            <div class="detail-text">(The Gap score)</div>
                        </td>
                    </tr>`;
            }
            if (j > 0) {
              const prevScore = matrix[i][j - 1];
              const total = prevScore + params.gap;
              tooltipContent += `
                    <tr>
                        <th>Score from Side</th>
                        <td>${prevScore} + (${params.gap}) = <b>${total}</b>
                             <div class="detail-text">(The Gap score)</div>
                        </td>
                    </tr>`;
            }
            if (type === "Local") {
              tooltipContent += `
                    <tr>
                        <th>Score from Start</th>
                        <td><b>0</b> <div class="detail-text">(Min score for Local Alignment)</div></td>
                    </tr>`;
            }
            tooltipContent += `
                <tr>
                    <th>Winning (max) score</th>
                    <td class="winning-score">${matrix[i][j]}</td>
                </tr>`;

            tooltipContent += "</table>";
            this.displayTooltip(tooltipContent, event);
          },

          highlightCell(i, j) {
            const cell = this.elements.matrixDisplay.querySelector(
              `[data-i="${i}"][data-j="${j}"]`
            );
            if (cell) cell.classList.add("cell-source");
          },

          addInitialUpgmaSequences() {
            this.addUpgmaSequence("Human", "GATTACA");
            this.addUpgmaSequence("Chimp", "GCTTACA");
            this.addUpgmaSequence("Gorilla", "GATTAGA");
          },

          addUpgmaSequence(name = "", sequence = "") {
            this.state.upgmaSeqCount++;
            const div = document.createElement("div");
            div.className = "seq-item";
            div.innerHTML = `
            <label>Name:</label>
            <input type="text" class="upgma-name" value="${
              name || "Seq" + this.state.upgmaSeqCount
            }">
            <label>Sequence:</label>
            <input type="text" class="upgma-seq" value="${
              sequence || this.generateRandomSequence(8)
            }">
            <button class="remove-btn">Remove</button>
            <div class="input-warning upgma-warning"></div>
            `;
            div
              .querySelector(".remove-btn")
              .addEventListener("click", (e) =>
                this.elements.seqContainer.children.length > 2
                  ? e.currentTarget.parentElement.remove()
                  : alert("At least two sequences are required.")
              );
            div
              .querySelector(".upgma-seq")
              .addEventListener("input", this.sanitizeAndWarn.bind(this));
            this.elements.seqContainer.appendChild(div);
          },

          upgmaFromSequences(sequences, names, distanceMethod) {
            const distance = (s1, s2) => {
              const len = Math.min(s1.length, s2.length);
              if (len === 0) {
                if (s1.length === 0 && s2.length === 0) return 0;
                return distanceMethod === "equation"
                  ? 1
                  : Math.max(s1.length, s2.length);
              }

              let diff = 0;
              for (let i = 0; i < len; i++) {
                if (s1[i] !== s2[i]) diff++;
              }

              if (distanceMethod === "equation") {
                return diff / len;
              } else {
                diff += Math.abs(s1.length - s2.length);
                return diff;
              }
            };

            let clusters = sequences.map((seq, i) => ({
              label: names[i],
              members: [seq],
              height: 0,
              isLeaf: true,
            }));
            const steps = [],
              matrices = [];
            while (clusters.length > 1) {
              const distMatrix = Array(clusters.length)
                .fill(null)
                .map(() => Array(clusters.length).fill(Infinity));
              let minDist = Infinity,
                minI = -1,
                minJ = -1;
              for (let i = 0; i < clusters.length; i++) {
                for (let j = i + 1; j < clusters.length; j++) {
                  let totalDist = 0;
                  clusters[i].members.forEach((m1) =>
                    clusters[j].members.forEach(
                      (m2) => (totalDist += distance(m1, m2))
                    )
                  );
                  distMatrix[i][j] = distMatrix[j][i] =
                    totalDist /
                    (clusters[i].members.length * clusters[j].members.length);
                  if (distMatrix[i][j] < minDist) {
                    minDist = distMatrix[i][j];
                    minI = i;
                    minJ = j;
                  }
                }
              }

              const clustersCopy = JSON.parse(JSON.stringify(clusters));
              matrices.push({
                matrix: distMatrix,
                labels: clusters.map((c) => c.label),
                clusters: clustersCopy,
              });

              const c1 = clusters[minI],
                c2 = clusters[minJ];
              steps.push(
                `Merging '${c1.label}' and '${
                  c2.label
                }' at distance ${minDist.toFixed(2)}.`
              );
              const newCluster = {
                label: `(${c1.label}, ${c2.label})`,
                members: [...c1.members, ...c2.members],
                height: minDist / 2,
                children: [c1, c2],
                isLeaf: false,
              };
              clusters.splice(Math.max(minI, minJ), 1);
              clusters.splice(Math.min(minI, minJ), 1, newCluster);
            }
            return { tree: clusters[0], steps, matrices };
          },

          upgmaFromMatrix(initialMatrix, initialLabels) {
            let clusters = initialLabels.map((label) => ({
              label: label,
              height: 0,
              isLeaf: true,
            }));
            const steps = [],
              matrices = [];

            let currentMatrix = initialMatrix;

            while (clusters.length > 1) {
              matrices.push({
                matrix: currentMatrix,
                labels: clusters.map((c) => c.label),
                clusters: JSON.parse(JSON.stringify(clusters)),
              });

              let minDist = Infinity,
                minI = -1,
                minJ = -1;
              for (let i = 0; i < currentMatrix.length; i++) {
                for (let j = i + 1; j < currentMatrix.length; j++) {
                  if (currentMatrix[i][j] < minDist) {
                    minDist = currentMatrix[i][j];
                    minI = i;
                    minJ = j;
                  }
                }
              }

              const c1 = clusters[minI],
                c2 = clusters[minJ];
              steps.push(
                `Merging '${c1.label}' and '${
                  c2.label
                }' at distance ${minDist.toFixed(2)}.`
              );
              const newCluster = {
                label: `(${c1.label}, ${c2.label})`,
                height: minDist / 2,
                children: [c1, c2],
                isLeaf: false,
              };

              const newSize = clusters.length - 1;
              const newMatrix = Array(newSize)
                .fill(0)
                .map(() => Array(newSize).fill(Infinity));
              const newClusters = [];
              let newI = 0;
              for (let i = 0; i < clusters.length; i++) {
                if (i === minI || i === minJ) continue;
                newClusters.push(clusters[i]);
                let newJ = 0;
                for (let j = 0; j < clusters.length; j++) {
                  if (j === minI || j === minJ) continue;
                  newMatrix[newI][newJ] = currentMatrix[i][j];
                  newJ++;
                }
                newI++;
              }

              // Calculate distances for the new cluster
              const newClusterDistances = [];
              for (let i = 0; i < clusters.length; i++) {
                if (i === minI || i === minJ) continue;
                const dist =
                  (currentMatrix[minI][i] + currentMatrix[minJ][i]) / 2;
                newClusterDistances.push(dist);
              }

              for (let i = 0; i < newClusterDistances.length; i++) {
                newMatrix[i][newSize - 1] = newMatrix[newSize - 1][i] =
                  newClusterDistances[i];
              }

              newClusters.push(newCluster);
              clusters = newClusters;
              currentMatrix = newMatrix;
            }
            return { tree: clusters[0], steps, matrices };
          },

          displayUPGMAResults({ tree, steps, matrices }) {
            const allDistances = matrices.flatMap((m) =>
              m.matrix.flat().filter((d) => d !== Infinity)
            );
            if (allDistances.every((d) => d === 0)) {
              this.elements.upgmaInfoContainer.innerHTML = `<div class="result-note">All sequences are identical - distances collapsed to 0.</div>`;
            }

            this.elements.stepLog.innerHTML = steps
              .map((step, i) => `<b>Step ${i + 1}:</b> ${step}`)
              .join("<br>");
            this.elements.distanceMatrices.innerHTML = matrices
              .map((data, i) => {
                let html = `<h4>${
                  i === 0 ? "Initial" : "Step " + (i + 1)
                } Distance Matrix</h4><table><thead><tr><th></th>${data.labels
                  .map((l) => `<th>${l}</th>`)
                  .join("")}</tr></thead><tbody>`;
                data.matrix.forEach((row, r) => {
                  html += `<tr><th>${data.labels[r]}</th>`;
                  row.forEach((cell, c) => {
                    html += `<td data-matrix-idx="${i}" data-row-idx="${r}" data-col-idx="${c}">
                                ${cell === Infinity ? "-" : cell.toFixed(2)}
                               </td>`;
                  });
                  html += `</tr>`;
                });
                return html + "</tbody></table>";
              })
              .join("");

            this.addUPGMAEventListeners();
            this.drawUPGMATree(tree);
            this.elements.upgmaResults.classList.add("visible");
          },

          addUPGMAEventListeners() {
            this.elements.distanceMatrices
              .querySelectorAll("td")
              .forEach((cell) => {
                cell.addEventListener("click", (e) => {
                  const matrixIdx = parseInt(e.currentTarget.dataset.matrixIdx);
                  const rowIdx = parseInt(e.currentTarget.dataset.rowIdx);
                  const colIdx = parseInt(e.currentTarget.dataset.colIdx);
                  this.showUPGMACalculationTooltip(
                    matrixIdx,
                    rowIdx,
                    colIdx,
                    e
                  );
                });
              });
          },

          showUPGMACalculationTooltip(matrixIdx, rowIdx, colIdx, event) {
            const { matrices, distanceMethod } = this.state.lastUPGMAResult;
            const matrixData = matrices[matrixIdx];
            const cluster1 = matrixData.clusters[rowIdx];
            const cluster2 = matrixData.clusters[colIdx];
            const finalValue = matrixData.matrix[rowIdx][colIdx];
            let tooltipContent = "";

            if (rowIdx === colIdx) {
              tooltipContent = `<h4>Calculation for (${cluster1.label}, ${cluster1.label})</h4><div>Distance to self is always 0.</div>`;
              this.displayTooltip(tooltipContent, event);
              return;
            }

            if (rowIdx > colIdx) [rowIdx, colIdx] = [colIdx, rowIdx];

            tooltipContent = `<h4>Calculation for (${cluster1.label}, ${cluster2.label})</h4>`;

            // This tooltip logic is complex for merged clusters from matrix input.
            // For now, we simplify and show the merge calculation if it's not the initial matrix.
            if (matrixIdx > 0) {
              // Try to find the source clusters in the previous matrix
              const prevMatrixData = matrices[matrixIdx - 1];
              const sourceLabel = cluster1.label; // e.g. "(Human, Chimp)"
              const mergedLabels = sourceLabel
                .replace(/[()]/g, "")
                .split(/,\s*/);
              const prevC1_label = mergedLabels[mergedLabels.length - 2];
              const prevC2_label = mergedLabels[mergedLabels.length - 1];

              const prev_idx1 = prevMatrixData.labels.indexOf(prevC1_label);
              const prev_idx2 = prevMatrixData.labels.indexOf(prevC2_label);
              const other_idx = prevMatrixData.labels.indexOf(cluster2.label);

              if (prev_idx1 > -1 && prev_idx2 > -1 && other_idx > -1) {
                const val1 = prevMatrixData.matrix[other_idx][prev_idx1];
                const val2 = prevMatrixData.matrix[other_idx][prev_idx2];
                tooltipContent += `<div class="upgma-calc-detail">This value is the average of the previous distances from '${cluster2.label}' to the merged components '${prevC1_label}' and '${prevC2_label}'.</div>`;
                tooltipContent += `<hr><div><b>Average Calculation:</b><br>
                               (${val1.toFixed(2)} + ${val2.toFixed(
                  2
                )}) / 2 = <b class="winning-score">${finalValue.toFixed(
                  2
                )}</b></div>`;
                this.displayTooltip(tooltipContent, event);
                return;
              }
            }

            // Fallback for initial matrix or if logic above fails
            tooltipContent += `<div>Value is ${finalValue.toFixed(
              2
            )}. From initial matrix or previous step.</div>`;
            this.displayTooltip(tooltipContent, event);
          },

          displayTooltip(content, event) {
            const tooltip = this.elements.calcTooltip;
            tooltip.innerHTML = content;
            tooltip.classList.add("visible");
            const rect = event.currentTarget.getBoundingClientRect();

            requestAnimationFrame(() => {
              let x = rect.left + window.scrollX + rect.width / 2;
              let y = rect.top + window.scrollY + rect.height;
              const tooltipWidth = tooltip.offsetWidth;
              const tooltipHeight = tooltip.offsetHeight;

              x = x - tooltipWidth / 2; // Center it

              if (x + tooltipWidth > document.documentElement.clientWidth) {
                x = document.documentElement.clientWidth - tooltipWidth - 10;
              }
              if (
                y + tooltipHeight >
                document.documentElement.clientHeight + window.scrollY
              ) {
                y = rect.top + window.scrollY - tooltipHeight - 10;
              }

              tooltip.style.left = `${Math.max(10, x)}px`;
              tooltip.style.top = `${Math.max(10, y)}px`;
            });
          },

          // --- UPGMA Matrix Input Functions ---
          renderMatrixInput() {
            const size = this.state.matrixInputSize;
            const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let tableHTML = `<table class="matrix-input-table"><thead><tr><th></th>`;
            for (let i = 0; i < size; i++) {
              tableHTML += `<th><input type="text" class="matrix-label" data-index="${i}" value="${alphabet[i]}"></th>`;
            }
            tableHTML += `</tr></thead><tbody>`;
            for (let i = 0; i < size; i++) {
              tableHTML += `<tr><th><input type="text" class="matrix-label" data-index="${i}" value="${alphabet[i]}"></th>`;
              for (let j = 0; j < size; j++) {
                if (i === j) {
                  tableHTML += `<td><input type="number" value="0" disabled></td>`;
                } else {
                  tableHTML += `<td><input type="number" class="matrix-value" data-row="${i}" data-col="${j}" min="0" step="any"></td>`;
                }
              }
              tableHTML += `</tr>`;
            }
            tableHTML += `</tbody></table>`;
            this.elements.matrixInputDisplay.innerHTML = tableHTML;
            this.bindMatrixInputEvents();
          },

          bindMatrixInputEvents() {
            const labels =
              this.elements.matrixInputDisplay.querySelectorAll(
                ".matrix-label"
              );
            const values =
              this.elements.matrixInputDisplay.querySelectorAll(
                ".matrix-value"
              );

            labels.forEach((label) => {
              label.addEventListener("input", (e) => {
                const index = e.target.dataset.index;
                const value = e.target.value;
                this.elements.matrixInputDisplay
                  .querySelectorAll(`.matrix-label[data-index="${index}"]`)
                  .forEach((el) => (el.value = value));
              });
            });

            values.forEach((value) => {
              value.addEventListener("input", (e) => {
                const r = e.target.dataset.row;
                const c = e.target.dataset.col;
                const symmetricalCell =
                  this.elements.matrixInputDisplay.querySelector(
                    `.matrix-value[data-row="${c}"][data-col="${r}"]`
                  );
                if (symmetricalCell) {
                  symmetricalCell.value = e.target.value;
                }
              });
            });
          },

          readMatrixFromDOM() {
            const size = this.state.matrixInputSize;
            const labels = [];
            const matrix = Array(size)
              .fill(0)
              .map(() => Array(size).fill(0));
            const labelInputs =
              this.elements.matrixInputDisplay.querySelectorAll(
                "th .matrix-label"
              );

            for (let i = 0; i < size; i++) {
              labels.push(labelInputs[i].value.trim());
            }

            for (let r = 0; r < size; r++) {
              for (let c = 0; c < size; c++) {
                if (r === c) continue;
                const cell = this.elements.matrixInputDisplay.querySelector(
                  `input[data-row="${r}"][data-col="${c}"]`
                );
                const value = parseFloat(cell.value);
                if (isNaN(value)) {
                  throw new Error(
                    `Invalid input at (${labels[r]}, ${labels[c]}). Please enter a number.`
                  );
                }
                matrix[r][c] = value;
              }
            }
            return { matrix, labels };
          },

          getAllNodes(tree) {
            const nodes = [];
            function traverse(node) {
              if (!node) return;
              nodes.push(node);
              if (node.children) {
                node.children.forEach(traverse);
              }
            }
            traverse(tree);
            return nodes;
          },

          drawUPGMATree(tree) {
            if (!tree) return;
            const width = 900,
              height = 600,
              padding = 60,
              labelAreaWidth = 150;
            let leafCount = 0;
            const numLeaves = this.countLeaves(tree);

            const allNodes = this.getAllNodes(tree);
            let maxHeight = Math.max(...allNodes.map((n) => n.height));

            if (maxHeight === 0) {
              maxHeight = 0.1; // Add epsilon if all heights are 0
            }

            const assignY = (node) => {
              if (node.isLeaf) {
                node.y =
                  (leafCount++ * (height - padding * 2)) /
                    (numLeaves - 1 || 1) +
                  padding;
              } else {
                node.children.forEach(assignY);
                node.y = (node.children[0].y + node.children[1].y) / 2;
              }
            };

            const assignX = (node) => {
              node.x =
                (width - padding - labelAreaWidth) *
                  (1 - node.height / maxHeight) +
                padding;
              if (!node.isLeaf) node.children.forEach(assignX);
            };

            assignY(tree);
            assignX(tree);

            let svg = `<svg class="tree-svg" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;
            let lines = "";
            let nodes = "";
            let labels = "";

            const buildSvgElements = (node) => {
              if (node.isLeaf) {
                labels += `<text x="${node.x + 10}" y="${
                  node.y
                }" dy=".3em" font-size="16" font-weight="bold" fill="#333" style="text-anchor: start;">${
                  node.label
                }</text>`;
                lines += `<line x1="${node.x}" y1="${node.y}" x2="${
                  node.x + 5
                }" y2="${node.y}" stroke="#333" stroke-width="2"/>`;
              } else {
                const [c1, c2] = node.children;
                // Vertical line
                lines += `<line x1="${node.x}" y1="${c1.y}" x2="${node.x}" y2="${c2.y}" stroke="#333" stroke-width="2" stroke-linejoin="round"/>`;
                // Horizontal lines
                lines += `<line x1="${node.x}" y1="${c1.y}" x2="${c1.x}" y2="${c1.y}" stroke="#333" stroke-width="2" stroke-linejoin="round"/>`;
                lines += `<line x1="${node.x}" y1="${c2.y}" x2="${c2.x}" y2="${c2.y}" stroke="#333" stroke-width="2" stroke-linejoin="round"/>`;
                // Circular node
                nodes += `<circle cx="${node.x}" cy="${node.y}" r="4" fill="var(--primary-color)" />`;
                // Height label
                labels += `<text x="${node.x - 5}" y="${
                  node.y - 5
                }" font-size="12" fill="var(--secondary-color)" text-anchor="end">${node.height.toFixed(
                  2
                )}</text>`;
                node.children.forEach(buildSvgElements);
              }
            };
            buildSvgElements(tree);
            svg += lines + nodes + labels; // Draw lines first, then nodes, then labels
            this.elements.treeDisplay.innerHTML = svg + `</svg>`;
          },

          countLeaves: (node) => {
            if (!node) return 0;
            return node.isLeaf
              ? 1
              : node.children.reduce(
                  (sum, child) => sum + app.countLeaves(child),
                  0
                );
          },

          exportSVG() {
            const svgEl = this.elements.treeDisplay.querySelector("svg");
            if (!svgEl) {
              alert("No tree available to export.");
              return;
            }
            const link = document.createElement("a");
            link.href = URL.createObjectURL(
              new Blob([new XMLSerializer().serializeToString(svgEl)], {
                type: "image/svg+xml;charset=utf-8",
              })
            );
            link.download = "upgma_tree.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          },

          generateRandomSequence(length = 15) {
            const chars = "ATCG";
            return Array.from({ length }, () =>
              chars.charAt(Math.floor(Math.random() * chars.length))
            ).join("");
          },

          toggleButtonLoading(button, isLoading) {
            if (isLoading) {
              button.disabled = true;
              button.dataset.originalText = button.textContent;
              button.textContent = "Computing...";
            } else {
              button.disabled = false;
              if (button.dataset.originalText) {
                button.textContent = button.dataset.originalText;
              }
            }
          },
        };

        app.init();
      });
    </script>
  </body>
</html>
