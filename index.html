<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Bioinformatics Tool</title>
    <style>
      /* --- General Styling & Layout --- */
      :root {
        --primary-color: #667eea;
        --secondary-color: #764ba2;
        --danger-color: #ff6b6b;
        --success-color: #51cf66;
        --info-color: #17a2b8;
        --light-gray: #f8f9fa;
        --dark-text: #333;
        --light-text: #fff;
        --border-color: #ddd;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        min-height: 100vh;
        padding: 20px;
        color: var(--dark-text);
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: var(--light-text);
        border-radius: 15px;
        padding: 40px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      /* --- Typography --- */
      h1 {
        text-align: center;
        color: var(--primary-color);
        margin-bottom: 10px;
        font-size: 2.5em;
      }
      h3 {
        color: var(--secondary-color);
        margin-bottom: 15px;
        border-bottom: 2px solid var(--primary-color);
        padding-bottom: 5px;
      }
      h4 {
        color: #555;
        margin-bottom: 15px;
        font-size: 1.1em;
      }
      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 30px;
      }

      /* --- Forms & Inputs --- */
      .method-selector {
        margin-bottom: 40px;
      }
      label {
        font-weight: 600;
        display: block;
        margin-bottom: 8px;
      }
      .label-container {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .label-container label {
        margin-bottom: 0;
      }
      .align-select {
        width: auto;
        padding: 5px 8px;
        font-size: 14px;
        margin-left: 10px;
      }

      select,
      input[type="text"],
      input[type="number"],
      textarea {
        width: 100%;
        padding: 12px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s, box-shadow 0.3s;
      }

      select:focus,
      input:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 5px rgba(102, 126, 234, 0.5);
      }

      textarea {
        min-height: 100px;
        resize: vertical;
        font-family: "Courier New", monospace;
        text-transform: uppercase;
      }

      .input-section {
        margin-bottom: 30px;
      }
      .params {
        margin-bottom: 20px;
      }
      .input-section,
      .params {
        display: grid;
        gap: 20px;
      }
      .input-section {
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      }
      .params {
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      }

      /* --- Buttons --- */
      button {
        background: linear-gradient(
          135deg,
          var(--primary-color) 0%,
          var(--secondary-color) 100%
        );
        color: var(--light-text);
        border: none;
        padding: 15px 30px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        width: 100%;
        margin-top: 10px;
      }
      button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }
      button:active:not(:disabled) {
        transform: translateY(0);
      }
      button:disabled {
        background: #aaa;
        cursor: not-allowed;
      }

      .remove-btn {
        background: var(--danger-color);
      }
      .add-seq-btn {
        background: var(--success-color);
      }
      .export-btn {
        background: #007bff;
        margin-top: 20px;
      }
      .generate-btn {
        background: var(--info-color);
      }

      /* --- Random Sequence Generator --- */
      .random-seq-generator {
        border: 2px dashed var(--border-color);
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0 30px 0;
      }
      .random-seq-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
      }
      .random-control-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .random-control-group .generate-btn {
        margin-top: auto;
      } /* Pushes button to bottom */

      /* --- Sections & Results --- */
      .method-section {
        display: none;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
      }
      .method-section.active {
        display: block;
        opacity: 1;
      }
      .result-section {
        margin-top: 30px;
        padding: 20px;
        background: var(--light-gray);
        border-radius: 8px;
        display: none;
      }
      .result-section.visible {
        display: block;
      }
      .matrix-container,
      .distance-matrices-container {
        overflow-x: auto;
        margin: 20px 0;
        padding: 10px;
        background: var(--light-text);
        border-radius: 8px;
      }

      table {
        border-collapse: collapse;
        margin: 0 auto;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
      th,
      td {
        border: 1px solid var(--border-color);
        padding: 10px;
        text-align: center;
        min-width: 55px;
        height: 55px;
        transition: background-color 0.2s;
        position: relative;
      }
      th {
        background: var(--primary-color);
        color: var(--light-text);
        font-weight: 600;
      }
      td {
        cursor: help;
      }
      .cell-path {
        background-color: #a29bfe !important;
        color: var(--light-text);
        font-weight: bold;
      }
      /* MODIFIED: Changed hover color for better visibility */
      .cell-source {
        background-color: #fffbdd !important; /* A light yellow */
        color: #111 !important; /* Force text to be dark for readability */
      }
      .cell-source .trace-arrow {
        color: #111 !important; /* Ensure arrows are also dark */
      }

      /* --- Organized Arrow Styles --- */
      .trace-arrow {
        position: absolute;
        font-size: 1.2em;
        color: #333;
        font-weight: bold;
        line-height: 1;
        pointer-events: none;
      }
      .arrow-diag {
        top: 3px;
        left: 3px;
      }
      .arrow-up {
        top: 3px;
        left: 50%;
        transform: translateX(-50%);
      }
      .arrow-left {
        top: 50%;
        left: 3px;
        transform: translateY(-50%);
      }
      .cell-path .trace-arrow {
        color: var(--light-text);
      }

      .alignment-result {
        font-family: "Courier New", monospace;
        background: var(--light-text);
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        white-space: pre-wrap;
        word-break: break-all;
        font-size: 1.1em;
        line-height: 1.6;
      }
      .match-line {
        color: #888;
      }
      .score-display {
        font-size: 1.2em;
        font-weight: 600;
        color: var(--primary-color);
        margin: 15px 0;
      }

      /* --- UPGMA Specific --- */
      .seq-item {
        display: grid;
        grid-template-columns: auto 1fr auto 2fr auto;
        align-items: center;
        gap: 15px;
        margin-bottom: 20px;
      }
      .seq-item label {
        margin: 0;
      }
      .upgma-options {
        margin: 25px 0;
        padding: 20px;
        border: 2px dashed var(--border-color);
        border-radius: 8px;
      }
      .remove-btn {
        width: auto;
        margin: 0;
      }
      .tree-container {
        margin-top: 20px;
        padding: 20px;
        background: var(--light-text);
        border-radius: 8px;
        text-align: center;
        overflow-x: auto;
      }
      .tree-svg {
        border: 2px solid var(--border-color);
        border-radius: 8px;
        width: 100%;
        height: auto;
      }
      .step-log {
        text-align: left;
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
        font-family: "Courier New", monospace;
      }

      /* --- Calculation Tooltip --- */
      .calc-tooltip {
        display: none;
        position: absolute;
        background-color: #2c3e50;
        color: white;
        padding: 15px;
        border: 1px solid #fff;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        z-index: 1000;
        font-size: 0.9em;
        width: auto;
        max-width: 500px;
      }
      .calc-tooltip table {
        width: 100%;
        border-collapse: collapse;
        box-shadow: none;
      }
      .calc-tooltip th,
      .calc-tooltip td {
        border: 1px solid #465d77;
        padding: 8px;
        text-align: left;
        min-width: auto;
        height: auto;
        color: white;
      }
      .calc-tooltip th {
        background: none;
        font-weight: bold;
        width: 40%;
      }
      .calc-tooltip .winning-score {
        font-weight: bold;
        color: #51cf66; /* success color */
      }
      .calc-tooltip .detail-text,
      .calc-tooltip .upgma-calc-detail {
        font-style: italic;
        font-size: 0.9em;
        color: #bdc3c7;
      }
      .calc-tooltip h4 {
        color: var(--light-text);
        margin-bottom: 10px;
        border-bottom: 1px solid #465d77;
        padding-bottom: 5px;
      }

      /* --- Signature --- */
      .signature {
        position: fixed;
        bottom: 10px;
        right: 15px;
        font-size: 12px;
        color: #fff;
        opacity: 0.7;
        font-family: "Courier New", monospace;
        z-index: 1001;
      }

      /* --- Responsive Design --- */
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .container {
          padding: 20px;
        }
        h1 {
          font-size: 2em;
        }
        .input-section,
        .params,
        .random-seq-controls {
          grid-template-columns: 1fr;
        }
        .seq-item {
          grid-template-columns: 1fr;
          gap: 10px;
        }
        .seq-item label {
          margin-bottom: 0;
          margin-top: 10px;
        }
        .seq-item label:first-of-type {
          margin-top: 0;
        }
        .remove-btn {
          width: 100%;
          margin-top: 10px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üß¨ Advanced Bioinformatics Tool</h1>
      <p class="subtitle">
        Global Alignment ‚Ä¢ Local Alignment ‚Ä¢ UPGMA Tree Building
      </p>
      <div class="method-selector">
        <label for="method">Select Method:</label>
        <select id="method">
          <option value="global">Global Alignment (Needleman-Wunsch)</option>
          <option value="local">Local Alignment (Smith-Waterman)</option>
          <option value="upgma">UPGMA Tree Building</option>
        </select>
      </div>

      <!-- Alignment Section (Global/Local) -->
      <div id="alignment-section" class="method-section active">
        <div class="input-section">
          <div>
            <div class="label-container">
              <label for="seq1">Sequence 1:</label>
              <select id="seq1-align" class="align-select">
                <option value="row" selected>Align to Row</option>
                <option value="col">Align to Column</option>
              </select>
            </div>
            <textarea id="seq1" placeholder="e.g., GATTACA">GATTACA</textarea>
          </div>
          <div>
            <div class="label-container">
              <label for="seq2">Sequence 2:</label>
              <select id="seq2-align" class="align-select">
                <option value="row">Align to Row</option>
                <option value="col" selected>Align to Column</option>
              </select>
            </div>
            <textarea id="seq2" placeholder="e.g., GTCGACGCA">
GTCGACGCA</textarea
            >
          </div>
        </div>
        <div class="params">
          <div>
            <label for="match">Match Score:</label
            ><input type="number" id="match" value="1" />
          </div>
          <div>
            <label for="mismatch">Mismatch Score:</label
            ><input type="number" id="mismatch" value="-1" />
          </div>
          <div>
            <label for="gap">Gap Penalty:</label
            ><input type="number" id="gap" value="-1" />
          </div>
          <div>
            <label for="traceback-priority"
              >Traceback Priority (for ties):</label
            >
            <select id="traceback-priority">
              <option value="diag-up-left" selected>
                Diagonal ‚Üí Up ‚Üí Left (Standard)
              </option>
              <option value="diag-left-up">Diagonal ‚Üí Left ‚Üí Up</option>
              <option value="up-diag-left">Up ‚Üí Diagonal ‚Üí Left</option>
              <option value="left-diag-up">Left ‚Üí Diagonal ‚Üí Up</option>
            </select>
          </div>
        </div>
        <!-- Random Sequence Generator -->
        <div class="random-seq-generator">
          <h4>Random Sequence Generator</h4>
          <div class="random-seq-controls">
            <div class="random-control-group">
              <label for="random-len1">Sequence 1 Length:</label>
              <input type="number" id="random-len1" value="15" min="1" />
              <button id="generate-seq1-btn" class="generate-btn">
                Generate for Sequence 1
              </button>
            </div>
            <div class="random-control-group">
              <label for="random-len2">Sequence 2 Length:</label>
              <input type="number" id="random-len2" value="15" min="1" />
              <button id="generate-seq2-btn" class="generate-btn">
                Generate for Sequence 2
              </button>
            </div>
          </div>
        </div>

        <button id="compute-alignment-btn">Compute Alignment</button>

        <div id="alignment-results" class="result-section">
          <h3>Alignment Matrix</h3>
          <p>Click on a cell to see its calculation details.</p>
          <div class="matrix-container" id="matrix-display"></div>
          <h3>Optimal Alignment</h3>
          <div class="score-display" id="score-display"></div>
          <div class="alignment-result" id="alignment-display"></div>
        </div>
      </div>

      <!-- UPGMA Section -->
      <div id="upgma-section" class="method-section">
        <div id="seq-container">
          <!-- Initial sequences will be added here by JS -->
        </div>
        <div class="upgma-options">
          <label for="upgma-distance-method"
            >Calculation of Initial Distance Matrix:</label
          >
          <select id="upgma-distance-method">
            <option value="traditional">
              Traditional Way (Absolute Difference)
            </option>
            <option value="equation">
              Use Equation (Number of Differences / Total Positions)
            </option>
          </select>
        </div>
        <button class="add-seq-btn" id="add-seq-btn">Add Sequence</button>
        <button id="build-upgma-btn">Build UPGMA Tree</button>
        <div id="upgma-results" class="result-section">
          <h3>UPGMA Clustering Process</h3>
          <div class="step-log" id="upgma-step-log"></div>
          <div class="distance-matrices-container" id="distance-matrices"></div>
          <h3>Phylogenetic Tree</h3>
          <div class="tree-container" id="tree-display"></div>
          <button class="export-btn" id="export-svg-btn">
            Export Tree as SVG
          </button>
        </div>
      </div>
      <!-- Calculation Tooltip -->
      <div id="calc-tooltip" class="calc-tooltip"></div>
    </div>
    <div class="signature">Made by Rahim</div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const app = {
          elements: {
            methodSelect: document.getElementById("method"),
            alignmentSection: document.getElementById("alignment-section"),
            upgmaSection: document.getElementById("upgma-section"),
            computeAlignmentBtn: document.getElementById(
              "compute-alignment-btn"
            ),
            buildUpgmaBtn: document.getElementById("build-upgma-btn"),
            addSeqBtn: document.getElementById("add-seq-btn"),
            exportSvgBtn: document.getElementById("export-svg-btn"),
            seq1Input: document.getElementById("seq1"),
            seq2Input: document.getElementById("seq2"),
            seq1Align: document.getElementById("seq1-align"),
            seq2Align: document.getElementById("seq2-align"),
            matchInput: document.getElementById("match"),
            mismatchInput: document.getElementById("mismatch"),
            gapInput: document.getElementById("gap"),
            tracebackPriority: document.getElementById("traceback-priority"), // ADD THIS LINE
            alignmentResults: document.getElementById("alignment-results"),
            matrixDisplay: document.getElementById("matrix-display"),
            scoreDisplay: document.getElementById("score-display"),
            alignmentDisplay: document.getElementById("alignment-display"),
            randomLen1Input: document.getElementById("random-len1"),
            generateSeq1Btn: document.getElementById("generate-seq1-btn"),
            randomLen2Input: document.getElementById("random-len2"),
            generateSeq2Btn: document.getElementById("generate-seq2-btn"),
            seqContainer: document.getElementById("seq-container"),
            upgmaDistanceMethod: document.getElementById(
              "upgma-distance-method"
            ),
            upgmaResults: document.getElementById("upgma-results"),
            stepLog: document.getElementById("upgma-step-log"),
            distanceMatrices: document.getElementById("distance-matrices"),
            treeDisplay: document.getElementById("tree-display"),
            calcTooltip: document.getElementById("calc-tooltip"),
          },
          state: {
            upgmaSeqCount: 0,
            lastAlignmentResult: null,
            lastUPGMAResult: null,
          },

          init() {
            this.addInitialUpgmaSequences();
            this.bindEvents();
          },

          bindEvents() {
            this.elements.methodSelect.addEventListener(
              "change",
              this.handleMethodSwitch.bind(this)
            );
            this.elements.computeAlignmentBtn.addEventListener(
              "click",
              this.handleAlignment.bind(this)
            );
            this.elements.buildUpgmaBtn.addEventListener(
              "click",
              this.handleUPGMA.bind(this)
            );
            this.elements.addSeqBtn.addEventListener("click", () =>
              this.addUpgmaSequence()
            );
            this.elements.exportSvgBtn.addEventListener(
              "click",
              this.exportSVG.bind(this)
            );
            this.elements.seq1Align.addEventListener(
              "change",
              this.handleAlignSwitch.bind(this)
            );
            this.elements.seq2Align.addEventListener(
              "change",
              this.handleAlignSwitch.bind(this)
            );

            document.addEventListener("click", (e) => {
              if (
                !e.target.closest("td") &&
                this.elements.calcTooltip.style.display === "block"
              ) {
                this.elements.calcTooltip.style.display = "none";
              }
            });

            this.elements.generateSeq1Btn.addEventListener("click", () => {
              const len = parseInt(this.elements.randomLen1Input.value) || 15;
              this.elements.seq1Input.value = this.generateRandomSequence(len);
            });
            this.elements.generateSeq2Btn.addEventListener("click", () => {
              const len = parseInt(this.elements.randomLen2Input.value) || 15;
              this.elements.seq2Input.value = this.generateRandomSequence(len);
            });
          },

          handleAlignSwitch(event) {
            const changedSelect = event.target;
            const otherSelect =
              changedSelect === this.elements.seq1Align
                ? this.elements.seq2Align
                : this.elements.seq1Align;

            if (changedSelect.value === "row") {
              otherSelect.value = "col";
            } else {
              otherSelect.value = "row";
            }
          },

          handleMethodSwitch() {
            const method = this.elements.methodSelect.value;
            this.elements.alignmentSection.classList.toggle(
              "active",
              method === "global" || method === "local"
            );
            this.elements.upgmaSection.classList.toggle(
              "active",
              method === "upgma"
            );
          },

          handleAlignment() {
            const btn = this.elements.computeAlignmentBtn;
            this.toggleButtonLoading(btn, true);
            setTimeout(() => {
              try {
                const method = this.elements.methodSelect.value;
                const seq1 = this.elements.seq1Input.value
                  .toUpperCase()
                  .replace(/\s/g, "");
                const seq2 = this.elements.seq2Input.value
                  .toUpperCase()
                  .replace(/\s/g, "");

                const seq1IsRow = this.elements.seq1Align.value === "row";
                const seq_v = seq1IsRow ? seq1 : seq2;
                const seq_h = seq1IsRow ? seq2 : seq1;

                if (!seq_v || !seq_h) {
                  alert("Please enter both sequences.");
                  return;
                }

                const match = parseInt(this.elements.matchInput.value);
                const mismatch = parseInt(this.elements.mismatchInput.value);
                const gap = parseInt(this.elements.gapInput.value);

                const result =
                  method === "global"
                    ? this.needlemanWunsch(seq_v, seq_h, match, mismatch, gap)
                    : this.smithWaterman(seq_v, seq_h, match, mismatch, gap);

                result.seq_v = seq_v;
                result.seq_h = seq_h;
                result.seq1IsRow = seq1IsRow;
                result.params = { match, mismatch, gap };

                this.state.lastAlignmentResult = result;
                this.displayAlignmentResults(result);
              } catch (e) {
                console.error("Alignment Error:", e);
                alert("An error occurred during alignment.");
              } finally {
                this.toggleButtonLoading(btn, false);
              }
            }, 50);
          },

          handleUPGMA() {
            const btn = this.elements.buildUpgmaBtn;
            this.toggleButtonLoading(btn, true);
            setTimeout(() => {
              try {
                const sequences = Array.from(
                  this.elements.seqContainer.querySelectorAll(".upgma-seq")
                ).map((el) => el.value.toUpperCase().replace(/\s/g, ""));
                const names = Array.from(
                  this.elements.seqContainer.querySelectorAll(".upgma-name")
                ).map((el) => el.value.trim());
                if (sequences.filter((s) => s).length < 2) {
                  alert("Please provide at least two sequences for UPGMA.");
                  return;
                }
                const distanceMethod = this.elements.upgmaDistanceMethod.value;
                const result = this.upgma(sequences, names, distanceMethod);

                result.distanceMethod = distanceMethod;
                this.state.lastUPGMAResult = result;

                this.displayUPGMAResults(result);
              } catch (e) {
                console.error("UPGMA Error:", e);
                alert("An error occurred during UPGMA tree construction.");
              } finally {
                this.toggleButtonLoading(btn, false);
              }
            }, 50);
          },

          needlemanWunsch(seq_v, seq_h, match, mismatch, gap) {
            const m = seq_v.length,
              n = seq_h.length;
            const matrix = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(0));
            const traceback = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(null));
            for (let i = 1; i <= m; i++) {
              matrix[i][0] = i * gap;
              traceback[i][0] = ["up"];
            }
            for (let j = 1; j <= n; j++) {
              matrix[0][j] = j * gap;
              traceback[0][j] = ["left"];
            }
            for (let i = 1; i <= m; i++) {
              for (let j = 1; j <= n; j++) {
                const matchScore =
                  seq_v[i - 1] === seq_h[j - 1] ? match : mismatch;
                const diag = matrix[i - 1][j - 1] + matchScore;
                const up = matrix[i - 1][j] + gap;
                const left = matrix[i][j - 1] + gap;

                const maxScore = Math.max(diag, up, left);
                matrix[i][j] = maxScore;

                traceback[i][j] = [];
                if (maxScore === diag) traceback[i][j].push("diag");
                if (maxScore === up) traceback[i][j].push("up");
                if (maxScore === left) traceback[i][j].push("left");
              }
            }
            const priority = this.elements.tracebackPriority
              ? this.elements.tracebackPriority.value
              : "diag-up-left";
            const { aligned_v, aligned_h, path } = this.getAlignment(
              traceback,
              seq_v,
              seq_h,
              m,
              n,
              false,
              priority
            );
            return {
              matrix,
              traceback,
              score: matrix[m][n],
              path,
              aligned_v,
              aligned_h,
              type: "Global",
              priority: priority, // ADD THIS LINE
            };
          },

          smithWaterman(seq_v, seq_h, match, mismatch, gap) {
            const m = seq_v.length,
              n = seq_h.length;
            const matrix = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(0));
            const traceback = Array(m + 1)
              .fill(null)
              .map(() => Array(n + 1).fill(null));
            let maxScore = 0,
              maxI = 0,
              maxJ = 0;
            for (let i = 1; i <= m; i++) {
              for (let j = 1; j <= n; j++) {
                const matchScore =
                  seq_v[i - 1] === seq_h[j - 1] ? match : mismatch;
                const diag = matrix[i - 1][j - 1] + matchScore;
                const up = matrix[i - 1][j] + gap;
                const left = matrix[i][j - 1] + gap;

                const currentMax = Math.max(0, diag, up, left);
                matrix[i][j] = currentMax;

                traceback[i][j] = [];
                if (currentMax === 0) {
                  traceback[i][j].push("stop");
                } else {
                  if (currentMax === diag) traceback[i][j].push("diag");
                  if (currentMax === up) traceback[i][j].push("up");
                  if (currentMax === left) traceback[i][j].push("left");
                }

                if (matrix[i][j] >= maxScore) {
                  // Use >= to find the bottom-most, right-most max score
                  maxScore = matrix[i][j];
                  maxI = i;
                  maxJ = j;
                }
              }
            }
            const priority = this.elements.tracebackPriority
              ? this.elements.tracebackPriority.value
              : "diag-up-left";
            const { aligned_v, aligned_h, path } = this.getAlignment(
              traceback,
              seq_v,
              seq_h,
              maxI,
              maxJ,
              true,
              priority
            );
            return {
              matrix,
              traceback,
              score: maxScore,
              path,
              aligned_v,
              aligned_h,
              type: "Local",
              priority: priority, // ADD THIS LINE
            };
          },

          getAlignment(
            traceback,
            seq_v,
            seq_h,
            i,
            j,
            isLocal = false,
            priority = "diag-up-left"
          ) {
            let aligned_v = "",
              aligned_h = "";
            const path = new Set();
            while (i > 0 || j > 0) {
              path.add(`${i},${j}`);
              const directions = traceback[i][j];
              if (!directions || directions.length === 0) break;
              // Determine direction based on priority
              let direction;
              const priorityOrder = priority.split("-");
              for (const dir of priorityOrder) {
                if (directions.includes(dir)) {
                  direction = dir;
                  break;
                }
              }

              if (!direction) direction = directions[0];
              if (isLocal && direction === "stop") break;

              if (direction === "diag") {
                aligned_v = seq_v[--i] + aligned_v;
                aligned_h = seq_h[--j] + aligned_h;
              } else if (direction === "up") {
                aligned_v = seq_v[--i] + aligned_v;
                aligned_h = "-" + aligned_h;
              } else if (direction === "left") {
                aligned_v = "-" + aligned_v;
                aligned_h = seq_h[--j] + aligned_h;
              } else break;
            }
            return { aligned_v, aligned_h, path };
          },

          displayAlignmentResults(result) {
            const {
              matrix,
              traceback,
              score,
              path,
              aligned_v,
              aligned_h,
              seq_v,
              seq_h,
              seq1IsRow,
              type,
            } = result;

            let tableHTML =
              "<table><thead><tr><th></th><th>-</th>" +
              [...seq_h].map((c) => `<th>${c}</th>`).join("") +
              "</tr></thead><tbody>";
            for (let i = 0; i <= seq_v.length; i++) {
              tableHTML += `<tr><th>${i === 0 ? "-" : seq_v[i - 1]}</th>`;
              for (let j = 0; j <= seq_h.length; j++) {
                let arrowHTML = "";
                if (traceback[i] && traceback[i][j]) {
                  const directions = traceback[i][j];
                  const isOnPath = path.has(`${i},${j}`);

                  let takenDirection = null;
                  if (isOnPath) {
                    if (
                      path.has(`${i - 1},${j - 1}`) &&
                      directions.includes("diag")
                    ) {
                      takenDirection = "diag";
                    } else if (
                      path.has(`${i - 1},${j}`) &&
                      directions.includes("up")
                    ) {
                      takenDirection = "up";
                    } else if (
                      path.has(`${i},${j - 1}`) &&
                      directions.includes("left")
                    ) {
                      takenDirection = "left";
                    }
                  }

                  if (directions.includes("diag")) {
                    const highlight =
                      takenDirection === "diag"
                        ? ' style="color: #ff6b6b; font-size: 1.5em; font-weight: bold;"'
                        : "";
                    arrowHTML += `<span class="trace-arrow arrow-diag"${highlight}>‚Üñ</span>`;
                  }
                  if (directions.includes("up")) {
                    const highlight =
                      takenDirection === "up"
                        ? ' style="color: #ff6b6b; font-size: 1.5em; font-weight: bold;"'
                        : "";
                    arrowHTML += `<span class="trace-arrow arrow-up"${highlight}>‚Üë</span>`;
                  }
                  if (directions.includes("left")) {
                    const highlight =
                      takenDirection === "left"
                        ? ' style="color: #ff6b6b; font-size: 1.5em; font-weight: bold;"'
                        : "";
                    arrowHTML += `<span class="trace-arrow arrow-left"${highlight}>‚Üê</span>`;
                  }
                }

                tableHTML += `<td data-i="${i}" data-j="${j}" class="${
                  path.has(`${i},${j}`) ? "cell-path" : ""
                }">${arrowHTML}${matrix[i][j]}</td>`;
              }
              tableHTML += "</tr>";
            }
            this.elements.matrixDisplay.innerHTML =
              tableHTML + "</tbody></table>";
            this.addMatrixEventListeners();
            this.elements.scoreDisplay.textContent = `${type} Alignment Score: ${score}`;

            const final_aligned1 = seq1IsRow ? aligned_v : aligned_h;
            const final_aligned2 = seq1IsRow ? aligned_h : aligned_v;

            let matchLine = [...final_aligned1]
              .map((c, i) =>
                c === final_aligned2[i]
                  ? "|"
                  : c === "-" || final_aligned2[i] === "-"
                  ? " "
                  : "."
              )
              .join("");
            this.elements.alignmentDisplay.innerHTML = `Seq 1: ${final_aligned1}<br><span class="match-line">       ${matchLine}</span><br>Seq 2: ${final_aligned2}`;

            // Add this:
            const pathCoords = Array.from(path)
              .sort((a, b) => {
                const [ai, aj] = a.split(",").map(Number);
                const [bi, bj] = b.split(",").map(Number);
                return bi + bj - (ai + aj);
              })
              .join(" ‚Üí ");

            this.elements.alignmentDisplay.innerHTML += `
            <div style="margin-top: 20px; padding: 15px; background: #e9ecef; border-radius: 8px; font-family: 'Courier New', monospace; word-break: break-all;">
                <b>Traceback Priority Used:</b> ${
                  result.priority || "diag-up-left"
                }<br>
                <b>Path Coordinates:</b> ${pathCoords}<br>
                <b>Alignment Score:</b> ${score}
            </div>`;

            this.elements.alignmentResults.classList.add("visible");
          },

          addMatrixEventListeners() {
            this.elements.matrixDisplay
              .querySelectorAll("td")
              .forEach((cell) => {
                cell.addEventListener("mouseover", (e) => {
                  const i = parseInt(e.currentTarget.dataset.i);
                  const j = parseInt(e.currentTarget.dataset.j);
                  if (i === 0 && j === 0) return;
                  const { traceback } = this.state.lastAlignmentResult;
                  const directions = traceback[i] ? traceback[i][j] || [] : [];
                  directions.forEach((direction) => {
                    if (direction === "diag" || direction === "stop")
                      this.highlightCell(i - 1, j - 1);
                    if (direction === "up" || direction === "stop")
                      this.highlightCell(i - 1, j);
                    if (direction === "left" || direction === "stop")
                      this.highlightCell(i, j - 1);
                  });
                });
                cell.addEventListener("mouseout", () =>
                  this.elements.matrixDisplay
                    .querySelectorAll(".cell-source")
                    .forEach((c) => c.classList.remove("cell-source"))
                );

                cell.addEventListener("click", (e) => {
                  const i = parseInt(e.currentTarget.dataset.i);
                  const j = parseInt(e.currentTarget.dataset.j);
                  this.showCalculationTooltip(i, j, e);
                });
              });
          },

          showCalculationTooltip(i, j, event) {
            const { matrix, seq_v, seq_h, params, type } =
              this.state.lastAlignmentResult;
            if (i === 0 && j === 0) return;

            let tooltipContent = "<table>";

            if (i > 0 && j > 0) {
              const prevScore = matrix[i - 1][j - 1];
              const charV = seq_v[i - 1];
              const charH = seq_h[j - 1];
              const isMatch = charV === charH;
              const scoreAdd = isMatch ? params.match : params.mismatch;
              const total = prevScore + scoreAdd;
              const reason = isMatch ? "match" : "mismatch";
              tooltipContent += `
                    <tr>
                        <th>Score from Diagonal</th>
                        <td>${prevScore} + ${scoreAdd} = <b>${total}</b>
                            <div class="detail-text">(Due to a ${reason} between ${charV} & ${charH})</div>
                        </td>
                    </tr>`;
            }
            if (i > 0) {
              const prevScore = matrix[i - 1][j];
              const total = prevScore + params.gap;
              tooltipContent += `
                    <tr>
                        <th>Score from Upper</th>
                        <td>${prevScore} + (${params.gap}) = <b>${total}</b>
                            <div class="detail-text">(The Gap score)</div>
                        </td>
                    </tr>`;
            }
            if (j > 0) {
              const prevScore = matrix[i][j - 1];
              const total = prevScore + params.gap;
              tooltipContent += `
                    <tr>
                        <th>Score from Side</th>
                        <td>${prevScore} + (${params.gap}) = <b>${total}</b>
                             <div class="detail-text">(The Gap score)</div>
                        </td>
                    </tr>`;
            }
            if (type === "Local") {
              tooltipContent += `
                    <tr>
                        <th>Score from Start</th>
                        <td><b>0</b> <div class="detail-text">(Min score for Local Alignment)</div></td>
                    </tr>`;
            }
            tooltipContent += `
                <tr>
                    <th>Winning (max) score</th>
                    <td class="winning-score">${matrix[i][j]}</td>
                </tr>`;

            tooltipContent += "</table>";
            this.displayTooltip(tooltipContent, event);
          },

          highlightCell(i, j) {
            const cell = this.elements.matrixDisplay.querySelector(
              `[data-i="${i}"][data-j="${j}"]`
            );
            if (cell) cell.classList.add("cell-source");
          },

          addInitialUpgmaSequences() {
            this.addUpgmaSequence("Human", "GATTACA");
            this.addUpgmaSequence("Chimp", "GCTTACA");
            this.addUpgmaSequence("Gorilla", "GATTAGA");
          },

          addUpgmaSequence(name = "", sequence = "") {
            this.state.upgmaSeqCount++;
            const div = document.createElement("div");
            div.className = "seq-item";
            div.innerHTML = `
            <label>Name:</label>
            <input type="text" class="upgma-name" value="${
              name || "Seq" + this.state.upgmaSeqCount
            }">
            <label>Sequence:</label>
            <input type="text" class="upgma-seq" value="${
              sequence || this.generateRandomSequence(8)
            }">
            <button class="remove-btn">Remove</button>`;
            div
              .querySelector(".remove-btn")
              .addEventListener("click", (e) =>
                this.elements.seqContainer.children.length > 2
                  ? e.currentTarget.parentElement.remove()
                  : alert("At least two sequences are required.")
              );
            this.elements.seqContainer.appendChild(div);
          },

          upgma(sequences, names, distanceMethod) {
            const distance = (s1, s2) => {
              const len = Math.min(s1.length, s2.length);
              if (len === 0)
                return distanceMethod === "equation"
                  ? 0
                  : Math.max(s1.length, s2.length);

              let diff = 0;
              for (let i = 0; i < len; i++) {
                if (s1[i] !== s2[i]) diff++;
              }

              if (distanceMethod === "equation") {
                return diff / len;
              } else {
                diff += Math.abs(s1.length - s2.length);
                return diff;
              }
            };

            let clusters = sequences.map((seq, i) => ({
              label: names[i],
              members: [seq],
              height: 0,
              isLeaf: true,
            }));
            const steps = [],
              matrices = [];
            while (clusters.length > 1) {
              const distMatrix = Array(clusters.length)
                .fill(null)
                .map(() => Array(clusters.length).fill(Infinity));
              let minDist = Infinity,
                minI = -1,
                minJ = -1;
              for (let i = 0; i < clusters.length; i++) {
                for (let j = i + 1; j < clusters.length; j++) {
                  let totalDist = 0;
                  clusters[i].members.forEach((m1) =>
                    clusters[j].members.forEach(
                      (m2) => (totalDist += distance(m1, m2))
                    )
                  );
                  distMatrix[i][j] = distMatrix[j][i] =
                    totalDist /
                    (clusters[i].members.length * clusters[j].members.length);
                  if (distMatrix[i][j] < minDist) {
                    minDist = distMatrix[i][j];
                    minI = i;
                    minJ = j;
                  }
                }
              }

              const clustersCopy = JSON.parse(JSON.stringify(clusters));
              matrices.push({
                matrix: distMatrix,
                labels: clusters.map((c) => c.label),
                clusters: clustersCopy,
              });

              const c1 = clusters[minI],
                c2 = clusters[minJ];
              steps.push(
                `Merging '${c1.label}' and '${
                  c2.label
                }' at distance ${minDist.toFixed(2)}.`
              );
              const newCluster = {
                label: `(${c1.label}, ${c2.label})`,
                members: [...c1.members, ...c2.members],
                height: minDist / 2,
                children: [c1, c2],
                isLeaf: false,
              };
              clusters.splice(Math.max(minI, minJ), 1);
              clusters.splice(Math.min(minI, minJ), 1, newCluster);
            }
            return { tree: clusters[0], steps, matrices };
          },

          displayUPGMAResults({ tree, steps, matrices }) {
            this.elements.stepLog.innerHTML = steps
              .map((step, i) => `<b>Step ${i + 1}:</b> ${step}`)
              .join("<br>");
            this.elements.distanceMatrices.innerHTML = matrices
              .map((data, i) => {
                let html = `<h4>${
                  i === 0 ? "Initial" : "Step " + (i + 1)
                } Distance Matrix</h4><table><thead><tr><th></th>${data.labels
                  .map((l) => `<th>${l}</th>`)
                  .join("")}</tr></thead><tbody>`;
                data.matrix.forEach((row, r) => {
                  html += `<tr><th>${data.labels[r]}</th>`;
                  row.forEach((cell, c) => {
                    html += `<td data-matrix-idx="${i}" data-row-idx="${r}" data-col-idx="${c}">
                                ${cell === Infinity ? "-" : cell.toFixed(2)}
                               </td>`;
                  });
                  html += `</tr>`;
                });
                return html + "</tbody></table>";
              })
              .join("");

            this.addUPGMAEventListeners();
            this.drawUPGMATree(tree);
            this.elements.upgmaResults.classList.add("visible");
          },

          addUPGMAEventListeners() {
            this.elements.distanceMatrices
              .querySelectorAll("td")
              .forEach((cell) => {
                cell.addEventListener("click", (e) => {
                  const matrixIdx = parseInt(e.currentTarget.dataset.matrixIdx);
                  const rowIdx = parseInt(e.currentTarget.dataset.rowIdx);
                  const colIdx = parseInt(e.currentTarget.dataset.colIdx);
                  this.showUPGMACalculationTooltip(
                    matrixIdx,
                    rowIdx,
                    colIdx,
                    e
                  );
                });
              });
          },

          showUPGMACalculationTooltip(matrixIdx, rowIdx, colIdx, event) {
            if (rowIdx === colIdx) {
              const matrixData = this.state.lastUPGMAResult.matrices[matrixIdx];
              const cluster = matrixData.clusters[rowIdx];
              this.displayTooltip(
                `<h4>Calculation for (${cluster.label}, ${cluster.label})</h4><div>Distance to self is always 0.</div>`,
                event
              );
              return;
            }

            if (rowIdx > colIdx) {
              [rowIdx, colIdx] = [colIdx, rowIdx];
            }

            const { matrices, distanceMethod } = this.state.lastUPGMAResult;
            const matrixData = matrices[matrixIdx];
            const cluster1 = matrixData.clusters[rowIdx];
            const cluster2 = matrixData.clusters[colIdx];
            const finalValue = matrixData.matrix[rowIdx][colIdx];

            let tooltipContent = `<h4>Calculation for (${cluster1.label}, ${cluster2.label})</h4>`;
            let details = "";
            let totalDist = 0;
            let comparisons = 0;

            cluster1.members.forEach((s1) => {
              cluster2.members.forEach((s2) => {
                const len = Math.min(s1.length, s2.length);
                let diff = 0;
                if (len > 0) {
                  for (let i = 0; i < len; i++) {
                    if (s1[i] !== s2[i]) diff++;
                  }
                }

                if (distanceMethod === "equation") {
                  const dist = len > 0 ? diff / len : 0;
                  totalDist += dist;
                  details += `<div>${s1} vs ${s2} &rarr; ${diff}/${len} = ${dist.toFixed(
                    2
                  )}</div>`;
                } else {
                  const dist = diff + Math.abs(s1.length - s2.length);
                  totalDist += dist;
                  details += `<div>${s1} vs ${s2} &rarr; ${dist} differences</div>`;
                }
                comparisons++;
              });
            });

            tooltipContent += `<div class="upgma-calc-detail"><b>Individual Comparisons:</b>${details}</div>`;
            tooltipContent += `<hr><div><b>Average Calculation:</b><br>
                               (${totalDist.toFixed(
                                 2
                               )}) / ${comparisons} = <b class="winning-score">${finalValue.toFixed(
              2
            )}</b></div>`;

            this.displayTooltip(tooltipContent, event);
          },

          displayTooltip(content, event) {
            const tooltip = this.elements.calcTooltip;
            tooltip.innerHTML = content;
            tooltip.style.display = "block";

            const rect = event.currentTarget.getBoundingClientRect();
            let x = rect.left + window.scrollX + rect.width / 2;
            let y = rect.top + window.scrollY + rect.height;

            tooltip.style.left = "0px";
            tooltip.style.top = "0px";
            const tooltipWidth = tooltip.offsetWidth;
            const tooltipHeight = tooltip.offsetHeight;

            if (x + tooltipWidth / 2 > document.documentElement.clientWidth) {
              x = document.documentElement.clientWidth - tooltipWidth - 5;
            } else {
              x = x - tooltipWidth / 2;
            }

            if (
              y + tooltipHeight >
              document.documentElement.clientHeight + window.scrollY
            ) {
              y = rect.top + window.scrollY - tooltipHeight - 5;
            }

            tooltip.style.left = `${Math.max(5, x)}px`;
            tooltip.style.top = `${Math.max(5, y)}px`;
          },

          drawUPGMATree(tree) {
            if (!tree) return;
            const width = 800,
              height = 500,
              padding = 60,
              labelAreaWidth = 150;
            let leafCount = 0;
            const numLeaves = this.countLeaves(tree);

            const assignY = (node) => {
              if (node.isLeaf) {
                node.y =
                  (leafCount++ * (height - padding * 2)) / (numLeaves - 1) +
                  padding;
              } else {
                node.children.forEach(assignY);
                node.y = (node.children[0].y + node.children[1].y) / 2;
              }
            };

            const assignX = (node) => {
              const maxH = tree.height || 1;
              node.x =
                (width - padding - labelAreaWidth) * (1 - node.height / maxH) +
                padding;
              if (!node.isLeaf) node.children.forEach(assignX);
            };

            assignY(tree);
            assignX(tree);

            let svg = `<svg class="tree-svg" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">`;

            const drawLinesAndLabels = (node) => {
              if (node.isLeaf) {
                svg += `<text x="${node.x + 8}" y="${
                  node.y
                }" dy=".3em" font-size="14" fill="#333" style="text-anchor: start;">${
                  node.label
                }</text>`;
              } else {
                const [c1, c2] = node.children;
                svg += `<line x1="${node.x}" y1="${c1.y}" x2="${node.x}" y2="${c2.y}" stroke="#555" stroke-width="1"/>`;
                svg += `<line x1="${node.x}" y1="${c1.y}" x2="${c1.x}" y2="${c1.y}" stroke="#555" stroke-width="1"/>`;
                svg += `<line x1="${node.x}" y1="${c2.y}" x2="${c2.x}" y2="${c2.y}" stroke="#555" stroke-width="1"/>`;
                svg += `<text x="${node.x - 4}" y="${
                  node.y - 4
                }" font-size="10" fill="var(--secondary-color)" text-anchor="end">${node.height.toFixed(
                  2
                )}</text>`;
                node.children.forEach(drawLinesAndLabels);
              }
            };
            drawLinesAndLabels(tree);
            this.elements.treeDisplay.innerHTML = svg + `</svg>`;
          },

          countLeaves: (node) => {
            if (!node) return 0;
            return node.isLeaf
              ? 1
              : node.children.reduce(
                  (sum, child) => sum + app.countLeaves(child),
                  0
                );
          },

          exportSVG() {
            const svgEl = this.elements.treeDisplay.querySelector("svg");
            if (!svgEl) {
              alert("No tree available to export.");
              return;
            }
            const link = document.createElement("a");
            link.href = URL.createObjectURL(
              new Blob([new XMLSerializer().serializeToString(svgEl)], {
                type: "image/svg+xml;charset=utf-8",
              })
            );
            link.download = "upgma_tree.svg";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          },

          generateRandomSequence(length = 15) {
            const chars = "ATCG";
            return Array.from({ length }, () =>
              chars.charAt(Math.floor(Math.random() * chars.length))
            ).join("");
          },

          toggleButtonLoading(button, isLoading) {
            if (isLoading) {
              button.disabled = true;
              button.dataset.originalText = button.textContent;
              button.textContent = "Computing...";
            } else {
              button.disabled = false;
              button.textContent = button.dataset.originalText;
            }
          },
        };

        app.init();
      });
    </script>
  </body>
</html>
